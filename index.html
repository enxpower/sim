<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Off-Grid Mining Microgrid · Single File · Progressive Charts + Trip State</title>
<meta name="description" content="Single-file microgrid simulation UI with progressive time-series rendering, mobile-friendly layout, and explicit trip/reclose state machine."/>
<style>
  :root{
    --bg:#ffffff;
    --panel:#ffffff;
    --muted:#f5f6f8;
    --border:#d9dde3;
    --text:#0b1220;
    --sub:#516075;

    --btn:#111111;
    --btnText:#ffffff;
    --danger:#b42318;
    --ok:#027a48;
    --warn:#b54708;

    --shadow: 0 8px 24px rgba(16,24,40,.08);

    --radius:14px;
    --gap:12px;

    --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  }

  html,body{height:100%}
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family:var(--font);
    line-height:1.35;
  }

  .wrap{
    max-width:1100px;
    margin:0 auto;
    padding:18px 14px 34px;
  }

  h1{
    margin:0 0 6px;
    font-size:18px;
    letter-spacing:.2px;
  }
  .sub{
    color:var(--sub);
    font-size:13px;
    margin:0 0 14px;
  }

  .grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:var(--gap);
    align-items:start;
  }

  .card{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:14px;
  }

  .card h2{
    margin:0 0 10px;
    font-size:16px;
  }

  .row{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }

  .kvs{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
  }

  .field{
    display:flex;
    flex-direction:column;
    gap:6px;
    min-width: 160px;
    flex: 1;
  }
  label{
    font-size:12px;
    color:var(--sub);
  }
  input, select, textarea{
    border:1px solid var(--border);
    border-radius:10px;
    padding:10px 10px;
    font-size:14px;
    outline:none;
    background:#fff;
    color:var(--text);
  }
  input:focus, select:focus, textarea:focus{
    box-shadow: 0 0 0 3px rgba(17,17,17,.12);
    border-color:#b8bdc6;
  }

  .btn{
    appearance:none;
    border:1px solid #0f172a;
    background:var(--btn);
    color:var(--btnText);
    padding:10px 12px;
    border-radius:12px;
    cursor:pointer;
    font-weight:700;
    font-size:13px;
    letter-spacing:.2px;
  }
  .btn:active{transform:translateY(1px)}
  .btn.secondary{
    background:#fff;
    color:#111;
    border:1px solid var(--border);
    font-weight:700;
  }
  .btn.danger{
    background:var(--danger);
    border-color:var(--danger);
  }
  .btn:disabled{
    opacity:.55;
    cursor:not-allowed;
  }

  .pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:8px 10px;
    border:1px solid var(--border);
    border-radius:999px;
    background:var(--muted);
    font-size:12px;
    color:var(--sub);
  }
  .dot{
    width:10px;height:10px;border-radius:999px;background:#9aa4b2;
  }
  .dot.ok{background:var(--ok)}
  .dot.warn{background:var(--warn)}
  .dot.bad{background:var(--danger)}

  .statusbar{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:space-between;
    flex-wrap:wrap;
    margin-top:8px;
  }
  .statusbar .left{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

  /* Charts */
  .chartWrap{
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .chartTitle{
    font-weight:800;
    font-size:14px;
    margin:0;
  }
  .legend{
    display:flex;
    flex-wrap:wrap;
    gap:8px 10px;
    align-items:center;
  }
  .lg{
    display:inline-flex;
    align-items:center;
    gap:8px;
    border:1px solid var(--border);
    background:#fff;
    padding:6px 9px;
    border-radius:999px;
    font-size:12px;
    color:var(--sub);
  }
  .sw{
    width:12px;height:12px;border-radius:4px;
    border:1px solid rgba(0,0,0,.15);
  }

  canvas{
    width:100%;
    height:360px;
    border:1px solid var(--border);
    border-radius:14px;
    background:#fff;
  }

  .hint{
    color:var(--sub);
    font-size:12px;
    margin:0;
  }

  /* Mobile */
  @media (max-width: 900px){
    .grid{grid-template-columns:1fr}
    canvas{height:320px}
    .kvs{grid-template-columns:1fr}
  }
  @media (max-width: 520px){
    /* a tiny bit tighter on phones so legends + charts breathe */
    .card{padding:12px}
    .lg{padding:6px 8px}
    canvas{height:290px}
  }
  @media (max-width: 420px){
    .wrap{padding:14px 10px 26px}
    .btn{width:100%}
    .row{gap:8px}
    canvas{height:270px}
    input,select{font-size:16px} /* avoid iOS zoom */
  }
</style>
</head>

<body>
<div class="wrap">
  <h1>Microgrid Simulation · Single File</h1>
  <p class="sub">Power / Frequency / Vmin / SOC charts render progressively over time. Trip/Reclose is an explicit state machine.</p>

  <div class="grid">
    <!-- Controls -->
    <div class="card">
      <h2>Controls</h2>

      <div class="kvs">
        <div class="field">
          <label>Mode</label>
          <select id="mode">
            <option value="grid">Grid-tied</option>
            <option value="island">Islanded</option>
          </select>
        </div>

        <div class="field">
          <label>Time step (s)</label>
          <input id="dt" type="number" value="0.5" min="0.05" step="0.05"/>
        </div>

        <div class="field">
          <label>Playback speed</label>
          <select id="speed">
            <option value="1">1×</option>
            <option value="2">2×</option>
            <option value="5" selected>5×</option>
            <option value="10">10×</option>
            <option value="20">20×</option>
          </select>
        </div>

        <div class="field">
          <label>Power chart render</label>
          <select id="powerRenderMode">
            <option value="progressive" selected>Progressive (from 0 to now)</option>
            <option value="window">Scroll window (last N minutes)</option>
          </select>
        </div>

        <div class="field">
          <label>Window size (min, for scroll window)</label>
          <input id="windowMin" type="number" value="10" min="1" step="1"/>
        </div>

        <div class="field">
          <label>Export CSV (demo)</label>
          <button class="btn secondary" id="exportBtn">Export current series</button>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid var(--border);margin:14px 0"/>

      <div class="kvs">
        <div class="field">
          <label>Trip delay (s)</label>
          <input id="tripDelay" type="number" value="0.25" min="0" step="0.05"/>
        </div>
        <div class="field">
          <label>Reclose after trip (s)</label>
          <input id="recloseDelay" type="number" value="30" min="0" step="1"/>
        </div>

        <div class="field">
          <label>UVLS stages (comma % of total load)</label>
          <input id="uvlsStages" type="text" value="10,10,10"/>
        </div>
        <div class="field">
          <label>UVLS note</label>
          <input type="text" value="Triggers when Vmin stays below UV for delay; each stage sheds that % of total load." disabled/>
        </div>
      </div>

      <div class="statusbar">
        <div class="left">
          <span class="pill"><span class="dot" id="gridDot"></span> <span id="gridState">Grid: Connected</span></span>
          <span class="pill mono">t = <span id="tNow">0.0</span>s</span>
          <span class="pill mono">run = <span id="runState">stopped</span></span>
        </div>
        <div class="row">
          <button class="btn" id="startBtn">Start</button>
          <button class="btn secondary" id="pauseBtn" disabled>Pause</button>
          <button class="btn secondary" id="resetBtn">Reset</button>
          <button class="btn danger" id="tripBtn">Trip</button>
        </div>
      </div>

      <div class="card" style="margin-top:12px;border-radius:12px;box-shadow:none;background:var(--muted)">
        <div class="row" style="justify-content:space-between">
          <div>
            <div style="font-weight:800;font-size:13px">Trip/Reclose Status</div>
            <div class="hint" id="tripHint">Armed. Press Trip to request a trip sequence.</div>
          </div>
          <div class="pill mono" id="tripPill">state=ARMED</div>
        </div>
        <div style="margin-top:10px" class="hint mono" id="tripTimeline">ARMED → (Trip) → TRIP_COUNTDOWN → TRIPPED_HOLD → RECLOSE_COUNTDOWN → RECLOSED</div>
        <div style="margin-top:8px" class="hint mono" id="tripExplain">
          Trip logic: (1) press Trip → wait Trip delay → OPEN; (2) optional OPEN-confirm hold → start reclose countdown; (3) when timer hits 0 → CLOSE.
        </div>
      </div>
    </div>

    <!-- Charts -->
    <div class="card">
      <div class="chartWrap">
        <div>
          <p class="chartTitle">Power (MW): PV / Wind / Load / Diesel / BESS / Grid-tie</p>
          <p class="hint">Fix: x-axis now grows with time (no “future” span at t=0). Curve reveals with time just like the Frequency chart.</p>
        </div>

        <div class="legend" id="powerLegend"></div>
        <canvas id="powerCanvas" width="1200" height="520"></canvas>

        <div style="height:6px"></div>

        <div>
          <p class="chartTitle">Frequency (Hz) + Vmin (pu) + SOC (%)</p>
          <p class="hint">Same progressive rendering style; tick labels avoid overlap on mobile.</p>
        </div>

        <div class="legend" id="stateLegend"></div>
        <canvas id="stateCanvas" width="1200" height="520"></canvas>
      </div>
    </div>
  </div>
</div>

<script>
/* ============================================================================
  Single-file microgrid UI
  - No external libs
  - Progressive chart rendering (fixes "curve fills axis at start")
  - Explicit Trip/Reclose state machine (fixes confusing countdown)
  - Mobile-safe layout + tick label overlap avoidance
============================================================================ */

/* -----------------------------
  Utilities
----------------------------- */
const $ = (id) => document.getElementById(id);

function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }

function parseCommaPercents(str){
  const arr = (str || "").split(",").map(s => Number(String(s).trim())).filter(n => Number.isFinite(n) && n>0);
  return arr.length ? arr : [10,10,10];
}

function downloadText(filename, text){
  const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/* -----------------------------
  Chart Renderer (Canvas)
  - Progressive reveal
  - Window mode (scroll)
  - Tick label overlap mitigation
----------------------------- */
function makeChart(canvas, opts){
  const ctx = canvas.getContext("2d");
  const cfg = Object.assign({
    paddingL: 64,
    paddingR: 18,
    paddingT: 18,
    paddingB: 54,
    gridX: 6,
    gridY: 5,
    font: "12px ui-sans-serif, system-ui",
    axisColor: "#111",
    gridColor: "#e6e8ec",
    textColor: "#516075",
    bg: "#fff",
    title: "",
    xLabel: "time",
    yLabel: "",
    y2Label: "",
    showZeroLine: true,
    zeroColor: "#c7cdd6",
    tickRotateDeg: 0, // set by auto for mobile
  }, opts || {});

  function resizeToCss(){
    // Keep canvas internal resolution matched to CSS size for crisp text.
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(320, Math.floor(rect.width * dpr));
    const h = Math.max(240, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
    return {w, h, dpr};
  }

  function niceTicks(min, max, count){
    if(!Number.isFinite(min) || !Number.isFinite(max) || min===max){
      return {min: min-1, max:max+1, step:1};
    }
    const span = Math.abs(max - min);
    const raw = span / Math.max(1, count);
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const steps = [1,2,5,10].map(k => k*pow);
    let step = steps[0];
    for(const s of steps){ if(raw <= s){ step = s; break; } }
    const niceMin = Math.floor(min/step)*step;
    const niceMax = Math.ceil(max/step)*step;
    return {min:niceMin, max:niceMax, step};
  }

  // Extra: format ticks to reduce clutter on narrow screens (fix overlap)
  function fmtTick(v, decimals){
    if(!Number.isFinite(v)) return "";
    const abs = Math.abs(v);
    if(abs >= 1000) return v.toFixed(0);
    return v.toFixed(decimals);
  }

  function drawAxes(xMin, xMax, yMin, yMax, y2Min, y2Max){
    const {w,h} = resizeToCss();

    // Auto rotate bottom ticks on small screens (fix overlap)
    const isNarrow = w < 900;
    const isPhone = w < 520;
    const rotate = isNarrow ? -28 : 0;

    // Mobile padding tweaks (fix y tick + label collision)
    const PL = isPhone ? 54 : cfg.paddingL;
    const PR = cfg.paddingR;
    const PT = cfg.paddingT;
    const PB = isPhone ? 62 : cfg.paddingB;

    // Dynamic grid density to avoid label stacking on very small widths
    const gridX = isPhone ? 4 : cfg.gridX;
    const gridY = cfg.gridY;

    ctx.fillStyle = cfg.bg;
    ctx.fillRect(0,0,w,h);

    ctx.font = cfg.font;
    ctx.textBaseline = "middle";
    ctx.textAlign = "left";

    const x0 = PL, x1 = w-PR;
    const y0 = h-PB, y1 = PT;

    // Grid
    ctx.strokeStyle = cfg.gridColor;
    ctx.lineWidth = 1;

    for(let i=0;i<=gridX;i++){
      const t = i/gridX;
      const x = lerp(x0, x1, t);
      ctx.beginPath();
      ctx.moveTo(x, y0);
      ctx.lineTo(x, y1);
      ctx.stroke();
    }
    for(let j=0;j<=gridY;j++){
      const t = j/gridY;
      const y = lerp(y0, y1, t);
      ctx.beginPath();
      ctx.moveTo(x0, y);
      ctx.lineTo(x1, y);
      ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = cfg.axisColor;
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(x0, y0); ctx.lineTo(x1, y0); // x
    ctx.moveTo(x0, y0); ctx.lineTo(x0, y1); // y
    ctx.stroke();

    // return mapping funcs for drawing data
    function mapX(v, a, b){
      const t = (v-a) / (b-a || 1);
      return lerp(x0, x1, t);
    }
    function mapY(v, a, b){
      const t = (v-a) / (b-a || 1);
      return lerp(y0, y1, 1-t);
    }

    // y ticks
    const yt = niceTicks(yMin, yMax, gridY);
    ctx.fillStyle = cfg.textColor;
    ctx.textAlign = "right";
    const yDecimals = isPhone ? 1 : 2;
    for(let j=0;j<=gridY;j++){
      const v = yt.min + (yt.max-yt.min)*(j/gridY);
      const y = mapY(v, yt.min, yt.max);
      ctx.fillText(fmtTick(v, yDecimals), x0-8, y);
    }

    // y2 ticks (optional)
    if(Number.isFinite(y2Min) && Number.isFinite(y2Max)){
      ctx.textAlign = "left";
      const y2t = niceTicks(y2Min, y2Max, gridY);
      const y2Decimals = isPhone ? 0 : 2;
      for(let j=0;j<=gridY;j++){
        const v = y2t.min + (y2t.max-y2t.min)*(j/gridY);
        const y = mapY(v, y2t.min, y2t.max);
        ctx.fillText(fmtTick(v, y2Decimals), x1+8, y);
      }
    }

    // x ticks (avoid overlap)
    const xt = niceTicks(xMin, xMax, gridX);
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    ctx.fillStyle = cfg.textColor;

    for(let i=0;i<=gridX;i++){
      const v = xt.min + (xt.max-xt.min)*(i/gridX);
      const x = mapX(v, xt.min, xt.max);
      const label = (v>=3600 ? (v/3600).toFixed(isPhone ? 1 : 2)+"h" : v.toFixed(0)+"s");

      ctx.save();
      ctx.translate(x, y0+18);
      ctx.rotate(rotate*Math.PI/180);
      ctx.fillText(label, 0, 0);
      ctx.restore();
    }

    // Zero line
    if(cfg.showZeroLine && yMin < 0 && yMax > 0){
      const yZ = mapY(0, yt.min, yt.max);
      ctx.strokeStyle = cfg.zeroColor;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(x0, yZ); ctx.lineTo(x1, yZ);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Labels
    ctx.fillStyle = cfg.axisColor;
    ctx.font = "700 12px ui-sans-serif, system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    if(cfg.yLabel){
      ctx.save();
      ctx.translate(14, (y0+y1)/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(cfg.yLabel, 0, 0);
      ctx.restore();
    }

    if(cfg.y2Label){
      ctx.save();
      ctx.translate(w-10, (y0+y1)/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(cfg.y2Label, 0, 0);
      ctx.restore();
    }

    return {w,h,x0,x1,y0,y1,mapX,mapY, xt, yt, gridX, gridY, isPhone, isNarrow};
  }

  function drawLines(frame, xMin, xMax, yMin, yMax, seriesList, y2){
    const ax = drawAxes(xMin, xMax, yMin, yMax, y2?.min, y2?.max);

    const clipPad = 2;
    ctx.save();
    ctx.beginPath();
    ctx.rect(ax.x0-clipPad, ax.y1-clipPad, (ax.x1-ax.x0)+2*clipPad, (ax.y0-ax.y1)+2*clipPad);
    ctx.clip();

    // draw each series
    for(const s of seriesList){
      const data = s.data;
      if(!data || data.length<2) continue;

      const useY2 = !!s.y2;
      const yA = useY2 ? y2.min : ax.yt.min;
      const yB = useY2 ? y2.max : ax.yt.max;

      ctx.strokeStyle = s.color;
      ctx.lineWidth = s.width || 2.0;
      ctx.globalAlpha = s.alpha ?? 1;

      ctx.beginPath();
      let started = false;
      for(let i=0;i<data.length;i++){
        const p = data[i];
        const x = ax.mapX(p.x, ax.xt.min, ax.xt.max);
        const y = ax.mapY(p.y, yA, yB);

        if(!started){
          ctx.moveTo(x,y);
          started = true;
        }else{
          ctx.lineTo(x,y);
        }
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  return {
    render(params){
      const {
        xMin, xMax,
        yMin, yMax,
        series,
        y2
      } = params;
      drawLines(null, xMin, xMax, yMin, yMax, series, y2);
    }
  };
}

/* -----------------------------
  Series Model
----------------------------- */
function makeSeries(){
  return {
    t: [],

    pv: [],
    wind: [],
    load: [],
    diesel: [],
    bess: [],
    grid: [],

    f: [],
    vmin: [],
    soc: [],
  };
}

function pushPoint(arr, x, y){ arr.push({x, y}); }

/* -----------------------------
  Demo simulation data
  - Replace this with your engine output
  - The important fix is: charts now render ONLY up to "current index"
----------------------------- */
const series = makeSeries();

let sim = {
  running: false,
  paused: false,
  t: 0,
  dt: 0.5,
  speed: 5,
  mode: "grid",

  // Trip state machine
  trip: {
    state: "ARMED",
    requestedAt: null,
    tripAt: null,
    trippedAt: null,
    recloseAt: null,

    tripDelay: 0.25,
    recloseDelay: 30,
    gridConnected: true,

    // Added: hold time after OPEN to make “countdown” logic explicit and readable
    openConfirmHold: 0.60,     // seconds to stay in TRIPPED_HOLD to show OPEN confirmed
    openConfirmedAt: null
  }
};

/* -----------------------------
  Trip/Reclose State Machine
  States:
    ARMED
    TRIP_COUNTDOWN
    TRIPPED_HOLD
    RECLOSE_COUNTDOWN
    RECLOSED
----------------------------- */
function setTripState(st){
  sim.trip.state = st;
  $("tripPill").textContent = "state=" + st;
}

function updateTripUI(){
  const st = sim.trip.state;

  const dot = $("gridDot");
  const gridTxt = $("gridState");

  if(sim.trip.gridConnected){
    dot.className = "dot ok";
    gridTxt.textContent = "Grid: Connected";
  }else{
    dot.className = "dot bad";
    gridTxt.textContent = "Grid: Disconnected";
  }

  const t = sim.t;

  // Clear + explicit messages (your feedback: countdown felt unclear)
  if(st === "ARMED"){
    $("tripHint").textContent = "Armed. Press Trip to request OPEN (Trip delay applies).";
    $("tripBtn").disabled = false;
  }
  else if(st === "TRIP_COUNTDOWN"){
    const left = Math.max(0, sim.trip.tripAt - t);
    $("tripHint").textContent = "Trip requested. Countdown to OPEN: " + left.toFixed(2) + "s (Trip delay).";
    $("tripBtn").disabled = true;
  }
  else if(st === "TRIPPED_HOLD"){
    const left = sim.trip.openConfirmedAt != null ? Math.max(0, sim.trip.openConfirmedAt - t) : 0;
    $("tripHint").textContent = "Breaker OPEN confirmed. Holding OPEN: " + left.toFixed(2) + "s before starting reclose countdown.";
    $("tripBtn").disabled = true;
  }
  else if(st === "RECLOSE_COUNTDOWN"){
    const left = Math.max(0, sim.trip.recloseAt - t);
    $("tripHint").textContent = "Reclose scheduled. Countdown to CLOSE: " + left.toFixed(1) + "s.";
    $("tripBtn").disabled = true;
  }
  else if(st === "RECLOSED"){
    $("tripHint").textContent = "Breaker CLOSED. Returning to ARMED.";
    $("tripBtn").disabled = false;
  }
}

/* Called when user presses Trip */
function requestTrip(){
  if(sim.trip.state !== "ARMED") return;
  const delay = Number($("tripDelay").value) || 0;
  sim.trip.tripDelay = delay;

  sim.trip.requestedAt = sim.t;
  sim.trip.tripAt = sim.t + delay;
  setTripState("TRIP_COUNTDOWN");
  // Note: actual opening happens in tick() when t >= tripAt
}

/* -----------------------------
  Rendering setup
----------------------------- */
const powerChart = makeChart($("powerCanvas"), {
  yLabel: "MW",
  font: "12px ui-sans-serif, system-ui"
});

const stateChart = makeChart($("stateCanvas"), {
  yLabel: "Hz / pu",
  y2Label: "SOC (%)",
  font: "12px ui-sans-serif, system-ui"
});

const COLORS = {
  pv:    "#f59e0b",
  wind:  "#b45309",
  load:  "#374151",
  diesel:"#2563eb",
  bess:  "#10b981",
  grid:  "#111827",

  f:     "#111827",
  vmin:  "#b42318",
  soc:   "#027a48"
};

function buildLegend(el, items){
  el.innerHTML = "";
  for(const it of items){
    const d = document.createElement("div");
    d.className = "lg";
    const sw = document.createElement("span");
    sw.className = "sw";
    sw.style.background = it.color;
    const name = document.createElement("span");
    name.textContent = it.label;
    d.appendChild(sw);
    d.appendChild(name);
    el.appendChild(d);
  }
}

buildLegend($("powerLegend"), [
  {label:"PV (MW)", color:COLORS.pv},
  {label:"Wind (MW)", color:COLORS.wind},
  {label:"Load (MW)", color:COLORS.load},
  {label:"Diesel (MW)", color:COLORS.diesel},
  {label:"BESS (MW)", color:COLORS.bess},
  {label:"Grid-tie (MW)", color:COLORS.grid},
]);

buildLegend($("stateLegend"), [
  {label:"Frequency (Hz)", color:COLORS.f},
  {label:"Vmin (pu)", color:COLORS.vmin},
  {label:"SOC (%)", color:COLORS.soc},
]);

/* -----------------------------
  Progressive render logic (the key fix)
  - At any time, we compute idxNow = last index where x <= sim.t
  - Then we slice arrays to that idx, so chart only draws history up to now
  - Window mode: only draw last N minutes
----------------------------- */
function lastIndexAtTime(arr, t){
  // arr = [{x,y}, ...], x is time(s)
  let lo=0, hi=arr.length-1, ans=-1;
  while(lo<=hi){
    const mid = (lo+hi)>>1;
    if(arr[mid].x <= t){ ans=mid; lo=mid+1; } else hi=mid-1;
  }
  return ans;
}

function sliceForRender(arr, idxFrom, idxTo){
  if(idxTo < 1) return [];
  const a = Math.max(0, idxFrom);
  const b = Math.min(arr.length, idxTo+1);
  return arr.slice(a,b);
}

function renderAll(){
  $("tNow").textContent = sim.t.toFixed(1);
  $("runState").textContent = sim.running ? (sim.paused ? "paused" : "running") : "stopped";

  const renderMode = $("powerRenderMode").value;
  const windowMin = Math.max(1, Number($("windowMin").value) || 10);
  const windowSec = windowMin * 60;

  // Determine render time range
  let xMin = 0;

  // KEY FIX YOU ASKED: x-axis should not “pre-span” to 10s at t=0.
  // It should grow with time (same feel as frequency). Still keep a tiny minimum to avoid divide-by-zero.
  let xMax = Math.max(sim.t, 1);

  if(renderMode === "window"){
    xMin = Math.max(0, sim.t - windowSec);
    xMax = Math.max(sim.t, xMin + 1);
  }

  // compute idx range based on time for each series (binary search)
  const idxPv = lastIndexAtTime(series.pv, sim.t);
  const idxWind = lastIndexAtTime(series.wind, sim.t);
  const idxLoad = lastIndexAtTime(series.load, sim.t);
  const idxDiesel = lastIndexAtTime(series.diesel, sim.t);
  const idxBess = lastIndexAtTime(series.bess, sim.t);
  const idxGrid = lastIndexAtTime(series.grid, sim.t);

  // find idxFrom for window mode (approx via searching xMin)
  const idxFromPv = renderMode==="window" ? lastIndexAtTime(series.pv, xMin) : 0;
  const idxFromWind = renderMode==="window" ? lastIndexAtTime(series.wind, xMin) : 0;
  const idxFromLoad = renderMode==="window" ? lastIndexAtTime(series.load, xMin) : 0;
  const idxFromDiesel = renderMode==="window" ? lastIndexAtTime(series.diesel, xMin) : 0;
  const idxFromBess = renderMode==="window" ? lastIndexAtTime(series.bess, xMin) : 0;
  const idxFromGrid = renderMode==="window" ? lastIndexAtTime(series.grid, xMin) : 0;

  const pPv = sliceForRender(series.pv, idxFromPv, idxPv);
  const pWind = sliceForRender(series.wind, idxFromWind, idxWind);
  const pLoad = sliceForRender(series.load, idxFromLoad, idxLoad);
  const pDiesel = sliceForRender(series.diesel, idxFromDiesel, idxDiesel);
  const pBess = sliceForRender(series.bess, idxFromBess, idxBess);
  const pGrid = sliceForRender(series.grid, idxFromGrid, idxGrid);

  // y range auto
  const allP = [pPv,pWind,pLoad,pDiesel,pBess,pGrid].flat();
  let yMin = 0, yMax = 1;
  if(allP.length){
    yMin = Math.min(...allP.map(p=>p.y));
    yMax = Math.max(...allP.map(p=>p.y));
    // pad range to avoid cramped top/bottom
    const pad = (yMax-yMin || 1) * 0.12;
    yMin -= pad; yMax += pad;
  }

  powerChart.render({
    xMin, xMax,
    yMin, yMax,
    series: [
      {data:pPv, color:COLORS.pv, width:2.2},
      {data:pWind, color:COLORS.wind, width:2.0, alpha:.95},
      {data:pLoad, color:COLORS.load, width:2.2},
      {data:pDiesel, color:COLORS.diesel, width:2.1},
      {data:pBess, color:COLORS.bess, width:2.1},
      {data:pGrid, color:COLORS.grid, width:2.0, alpha:.9},
    ]
  });

  // State chart
  const idxF = lastIndexAtTime(series.f, sim.t);
  const idxV = lastIndexAtTime(series.vmin, sim.t);
  const idxS = lastIndexAtTime(series.soc, sim.t);

  const idxFromF = renderMode==="window" ? lastIndexAtTime(series.f, xMin) : 0;
  const idxFromV = renderMode==="window" ? lastIndexAtTime(series.vmin, xMin) : 0;
  const idxFromS = renderMode==="window" ? lastIndexAtTime(series.soc, xMin) : 0;

  const pF = sliceForRender(series.f, idxFromF, idxF);
  const pV = sliceForRender(series.vmin, idxFromV, idxV);
  const pS = sliceForRender(series.soc, idxFromS, idxS);

  // y1 range covers Hz + pu on same axis (simple demo)
  const allY1 = [pF,pV].flat();
  let y1Min = 0.8, y1Max = 1.2;
  if(allY1.length){
    y1Min = Math.min(...allY1.map(p=>p.y));
    y1Max = Math.max(...allY1.map(p=>p.y));
    const pad = (y1Max-y1Min || 1)*0.18;
    y1Min -= pad; y1Max += pad;
  }

  // y2 for SOC
  let y2Min = 0, y2Max = 100;
  if(pS.length){
    y2Min = Math.min(...pS.map(p=>p.y));
    y2Max = Math.max(...pS.map(p=>p.y));
    const pad = (y2Max-y2Min || 1)*0.10;
    y2Min = clamp(y2Min - pad, 0, 100);
    y2Max = clamp(y2Max + pad, 0, 100);
  }

  stateChart.render({
    xMin, xMax,
    yMin: y1Min, yMax: y1Max,
    y2: {min:y2Min, max:y2Max},
    series: [
      {data:pF, color:COLORS.f, width:2.2, y2:false},
      {data:pV, color:COLORS.vmin, width:2.2, y2:false, alpha:.95},
      {data:pS, color:COLORS.soc, width:2.0, y2:true, alpha:.95},
    ]
  });

  updateTripUI();
}

/* -----------------------------
  Demo engine tick
  Replace with your microgrid-engine outputs.
----------------------------- */
function demoSignals(t){
  // Basic noisy profiles (MW)
  const load = 2.2 + 0.35*Math.sin(t/18) + 0.15*Math.sin(t/4) + 0.12*(Math.random()-0.5);
  const pv   = 0.8 + 0.6*Math.max(0, Math.sin((t/80)+0.6)) + 0.10*(Math.random()-0.5);
  const wind = 1.1 + 0.8*Math.sin(t/10) + 0.25*(Math.random()-0.5);

  let grid = sim.trip.gridConnected ? 0.6 + 0.4*Math.sin(t/25) : 0.0;

  // Diesel + BESS try to balance (very simplified)
  let net = load - (pv + wind + grid);
  let diesel = clamp(net*0.55, 0, 3.2);
  let bess = net - diesel;

  // clamp BESS power
  bess = clamp(bess, -2.0, 2.0);

  // Frequency and Vmin (toy model)
  const islandPenalty = sim.trip.gridConnected ? 0 : 1;
  const freq = 60 + (islandPenalty? (-0.25 + 0.15*Math.sin(t/6)) : (0.05*Math.sin(t/9))) + 0.02*(Math.random()-0.5);

  let vmin = 1.0 - (islandPenalty? 0.06 : 0.01) - 0.02*Math.max(0, net) + 0.01*Math.sin(t/7) + 0.01*(Math.random()-0.5);
  vmin = clamp(vmin, 0.75, 1.05);

  // SOC (toy integration)
  const prevSoc = series.soc.length ? series.soc[series.soc.length-1].y : 55;
  const soc = clamp(prevSoc - (bess*0.02) + 0.002*(Math.random()-0.5), 0, 100);

  return {pv, wind, load, diesel, bess, grid, freq, vmin, soc};
}

/* -----------------------------
  UVLS (demo effect)
  Here we show structure; integrate with your real logic if needed.
----------------------------- */
let uvls = { stage:0, lastTriggerT:null };

function applyUvls(loadMw, vmin, t){
  const stages = parseCommaPercents($("uvlsStages").value);
  const UV = 0.88;         // demo threshold
  const UV_DELAY = 0.25;   // demo delay seconds

  if(vmin < UV){
    if(uvls.lastTriggerT === null) uvls.lastTriggerT = t;
    const belowFor = t - uvls.lastTriggerT;
    if(belowFor >= UV_DELAY && uvls.stage < stages.length){
      // shed next stage
      const shedPct = stages[uvls.stage] / 100;
      uvls.stage++;
      uvls.lastTriggerT = t; // reset for next stage delay
      return loadMw * (1 - shedPct);
    }
  }else{
    uvls.lastTriggerT = null;
    uvls.stage = 0;
  }
  return loadMw;
}

/* -----------------------------
  Trip state progression in tick()
----------------------------- */

/* ORIGINAL tickTripState left here (not used) to satisfy “code only increases”.
function tickTripState(){
  const st = sim.trip.state;
  const t = sim.t;

  if(st === "TRIP_COUNTDOWN"){
    if(t >= sim.trip.tripAt){
      // OPEN breaker now
      sim.trip.gridConnected = false;
      setTripState("TRIPPED_HOLD");
      sim.trip.trippedAt = t;

      // schedule reclose (explicit)
      const recloseDelay = Number($("recloseDelay").value) || 0;
      sim.trip.recloseDelay = recloseDelay;
      sim.trip.recloseAt = t + recloseDelay;

      // If delay is 0, immediately proceed
      if(recloseDelay > 0){
        setTripState("RECLOSE_COUNTDOWN");
      }else{
        sim.trip.gridConnected = true;
        setTripState("RECLOSED");
      }
    }
  }
  else if(st === "TRIPPED_HOLD"){
    // In this simplified model we immediately go into reclose countdown
    setTripState("RECLOSE_COUNTDOWN");
  }
  else if(st === "RECLOSE_COUNTDOWN"){
    if(t >= sim.trip.recloseAt){
      sim.trip.gridConnected = true;
      setTripState("RECLOSED");
    }
  }
  else if(st === "RECLOSED"){
    // auto-return to ARMED
    setTripState("ARMED");
  }
}
*/

// Updated trip machine: makes the “countdown” meaning unambiguous.
// TRIP_COUNTDOWN counts to OPEN
// TRIPPED_HOLD counts a short OPEN-confirm hold
// RECLOSE_COUNTDOWN counts to CLOSE
function tickTripState_v2(){
  const st = sim.trip.state;
  const t = sim.t;

  if(st === "TRIP_COUNTDOWN"){
    if(t >= sim.trip.tripAt){
      // OPEN breaker now
      sim.trip.gridConnected = false;
      sim.trip.trippedAt = t;

      // Hold OPEN briefly so UI can clearly show “OPEN confirmed”
      sim.trip.openConfirmedAt = t + (sim.trip.openConfirmHold || 0);

      setTripState("TRIPPED_HOLD");
    }
  }
  else if(st === "TRIPPED_HOLD"){
    // wait until OPEN hold expires, then schedule/enter reclose countdown
    if(sim.trip.openConfirmedAt != null && t >= sim.trip.openConfirmedAt){
      const recloseDelay = Number($("recloseDelay").value) || 0;
      sim.trip.recloseDelay = recloseDelay;
      sim.trip.recloseAt = t + recloseDelay;

      if(recloseDelay > 0){
        setTripState("RECLOSE_COUNTDOWN");
      }else{
        sim.trip.gridConnected = true;
        setTripState("RECLOSED");
      }
    }
  }
  else if(st === "RECLOSE_COUNTDOWN"){
    if(t >= sim.trip.recloseAt){
      sim.trip.gridConnected = true;
      setTripState("RECLOSED");
    }
  }
  else if(st === "RECLOSED"){
    // auto-return to ARMED
    setTripState("ARMED");
  }
}

/* -----------------------------
  Main loop
----------------------------- */
let raf = null;
let lastWall = null;

function loop(wallTs){
  if(!sim.running) return;

  if(sim.paused){
    lastWall = wallTs;
    raf = requestAnimationFrame(loop);
    return;
  }

  if(lastWall === null) lastWall = wallTs;
  const wallDt = Math.min(0.05, Math.max(0, (wallTs - lastWall) / 1000));
  lastWall = wallTs;

  const speed = Number($("speed").value) || 1;
  sim.speed = speed;

  // advance simulation time
  sim.dt = Number($("dt").value) || 0.5;
  // We advance in fixed steps for stable series density
  let steps = Math.floor((wallDt * speed) / sim.dt);
  steps = clamp(steps, 1, 20);

  for(let k=0;k<steps;k++){
    sim.t += sim.dt;

    // trip state progression (use v2)
    tickTripState_v2();

    // generate signals
    const s = demoSignals(sim.t);

    // UVLS demo: modify load based on Vmin
    const load2 = applyUvls(s.load, s.vmin, sim.t);

    pushPoint(series.pv, sim.t, s.pv);
    pushPoint(series.wind, sim.t, s.wind);
    pushPoint(series.load, sim.t, load2);
    pushPoint(series.diesel, sim.t, s.diesel);
    pushPoint(series.bess, sim.t, s.bess);
    pushPoint(series.grid, sim.t, s.grid);

    pushPoint(series.f, sim.t, s.freq);
    pushPoint(series.vmin, sim.t, s.vmin);
    pushPoint(series.soc, sim.t, s.soc);

    // keep arrays bounded (avoid infinite memory)
    const MAX_POINTS = 20000;
    for(const key of Object.keys(series)){
      if(Array.isArray(series[key]) && series[key].length > MAX_POINTS){
        series[key].splice(0, series[key].length - MAX_POINTS);
      }
    }
  }

  renderAll();
  raf = requestAnimationFrame(loop);
}

/* -----------------------------
  Controls
----------------------------- */
$("mode").addEventListener("change", () => {
  sim.mode = $("mode").value;
});

$("startBtn").addEventListener("click", () => {
  if(!sim.running){
    sim.running = true;
    sim.paused = false;
    $("pauseBtn").disabled = false;
    lastWall = null;
    raf = requestAnimationFrame(loop);
  }else{
    sim.paused = false;
  }
  renderAll();
});

$("pauseBtn").addEventListener("click", () => {
  sim.paused = !sim.paused;
  $("pauseBtn").textContent = sim.paused ? "Resume" : "Pause";
  renderAll();
});

$("resetBtn").addEventListener("click", () => {
  sim.running = false;
  sim.paused = false;
  if(raf) cancelAnimationFrame(raf);
  raf = null;
  lastWall = null;

  // clear data
  for(const k of Object.keys(series)){
    if(Array.isArray(series[k])) series[k].length = 0;
  }

  sim.t = 0;

  // reset trip state
  sim.trip.gridConnected = true;
  sim.trip.openConfirmedAt = null;
  setTripState("ARMED");
  $("pauseBtn").textContent = "Pause";
  $("pauseBtn").disabled = true;

  renderAll();
});

$("tripBtn").addEventListener("click", () => {
  requestTrip();
  renderAll();
});

$("exportBtn").addEventListener("click", () => {
  // Demo CSV export
  const header = ["t","pv","wind","load","diesel","bess","grid","freq","vmin","soc"].join(",");
  const n = Math.min(series.pv.length, series.wind.length, series.load.length, series.diesel.length, series.bess.length, series.grid.length, series.f.length, series.vmin.length, series.soc.length);
  const rows = [];
  for(let i=0;i<n;i++){
    rows.push([
      series.pv[i].x.toFixed(2),
      series.pv[i].y.toFixed(4),
      series.wind[i].y.toFixed(4),
      series.load[i].y.toFixed(4),
      series.diesel[i].y.toFixed(4),
      series.bess[i].y.toFixed(4),
      series.grid[i].y.toFixed(4),
      series.f[i].y.toFixed(4),
      series.vmin[i].y.toFixed(4),
      series.soc[i].y.toFixed(2),
    ].join(","));
  }
  downloadText("microgrid_series.csv", header + "\n" + rows.join("\n"));
});

window.addEventListener("resize", () => renderAll());

/* -----------------------------
  Initial render
----------------------------- */
renderAll();
</script>
</body>
</html>
