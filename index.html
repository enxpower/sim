<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mining Microgrid Simulator — Single-File</title>
  <meta name="robots" content="noindex,nofollow" />
  <style>
    :root{
      --bg:#ffffff;
      --surface:#ffffff;
      --muted:#f5f7fa;
      --border:#e6e8ec;
      --text:#0b1220;
      --sub:#516075;
      --chip:#eef3ff;
      --shadow: 0 8px 30px rgba(16,24,40,.06);
      --radius:12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--text); background:var(--bg);
    }
    header{
      padding:14px 18px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(180deg,#fff, #fbfcfe);
      position:sticky; top:0; z-index:10;
    }
    .title{
      display:flex; align-items:baseline; justify-content:space-between; gap:12px;
      flex-wrap:wrap;
    }
    .title h1{ margin:0; font-size:16px; font-weight:650; letter-spacing:.2px; }
    .title .meta{ font-size:12px; color:var(--sub); }
    .wrap{ padding:16px 18px 24px; max-width:1400px; margin:0 auto; }
    .grid{
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 1100px){
      .grid{ grid-template-columns:1fr; }
    }
    .card{
      background:var(--surface);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card-h{
      padding:12px 12px;
      border-bottom:1px solid var(--border);
      background:var(--muted);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .card-h .h{
      font-size:12.5px; font-weight:700; letter-spacing:.2px;
    }
    .card-b{ padding:12px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .row > *{ flex:1 1 auto; }
    label{ display:block; font-size:11px; color:var(--sub); margin-bottom:5px; }
    input, select, textarea{
      width:100%;
      border:1px solid var(--border);
      border-radius:10px;
      padding:9px 10px;
      font-size:12.5px;
      outline:none;
      background:#fff;
    }
    textarea{ font-family:var(--mono); font-size:12px; min-height:110px; resize:vertical; }
    .btns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      border:1px solid var(--border);
      background:#fff;
      border-radius:10px;
      padding:9px 12px;
      font-size:12.5px;
      cursor:pointer;
    }
    button.primary{
      background:#0b5fff;
      border-color:#0b5fff;
      color:#fff;
    }
    button:active{ transform: translateY(1px); }
    .kpis{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:10px;
    }
    @media (max-width: 900px){
      .kpis{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    .kpi{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 10px;
      background:#fff;
    }
    .kpi .k{ font-size:11px; color:var(--sub); }
    .kpi .v{ font-size:16px; font-weight:750; margin-top:4px; }
    .kpi .s{ font-size:11px; color:var(--sub); margin-top:3px; }
    .mono{ font-family:var(--mono); }
    .plot-wrap{ padding:10px 12px 12px; }
    .plot-top{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:#fff;
      flex-wrap:wrap;
    }
    .plot-title{
      font-size:12.5px; font-weight:750;
    }

    /* Legend: colored text, matches curves */
    .legend{
      display:flex; flex-wrap:wrap; gap:10px 14px;
      align-items:center;
      font-size:12px;
    }
    .legend .item{
      display:inline-flex; align-items:center; gap:7px;
      user-select:none;
      cursor:pointer;
    }
    .sw{
      width:12px; height:3px; border-radius:999px;
      background:#000;
      display:inline-block;
    }
    .legend .muted{ opacity:.35; }

    canvas{ width:100%; height:340px; display:block; }
    .footer{
      padding:12px 18px;
      color:var(--sub);
      font-size:11px;
      border-top:1px solid var(--border);
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>Mining Microgrid Simulator — Single File</h1>
      <div class="meta mono" id="metaLine">MODE: — | t=—</div>
    </div>
  </header>

  <div class="wrap">
    <div class="grid">
      <!-- LEFT: Controls -->
      <div class="card">
        <div class="card-h">
          <div class="h">Run</div>
          <div class="mono" style="font-size:11px; color:var(--sub)" id="runState">READY</div>
        </div>
        <div class="card-b">
          <div class="row">
            <div>
              <label>Simulation length (hours)</label>
              <input id="simHours" type="number" min="0.1" step="0.1" value="24" />
            </div>
            <div>
              <label>Base time step dt (s)</label>
              <input id="dt" type="number" min="0.02" step="0.01" value="0.5" />
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div>
              <label>Grid Connected (PCC Closed)</label>
              <select id="gridConnected">
                <option value="yes">Yes (Grid-Connected)</option>
                <option value="no">No (Islanded)</option>
              </select>
            </div>
            <div>
              <label>Grid Strength</label>
              <select id="gridStrength">
                <option value="strong">Strong (Infinite Bus)</option>
                <option value="weak">Weak Grid</option>
              </select>
            </div>
          </div>

          <div class="btns">
            <button class="primary" id="btnStart">Start</button>
            <button id="btnPause">Pause</button>
            <button id="btnReset">Reset</button>
          </div>

          <div class="btns" style="margin-top:10px">
            <button id="btnTrip">Trip Grid (Open PCC)</button>
            <button id="btnReclose">Attempt Reclose</button>
          </div>

          <div style="margin-top:12px">
            <label>Event script (JSON array)</label>
            <textarea id="events">[
  { "t_s": 5400, "type": "wind_gust",  "sec": 120, "add_mps": 6 },
  { "t_s": 10800, "type": "pcc_open" },
  { "t_s": 12600, "type": "pcc_close" }
]</textarea>
          </div>
        </div>
      </div>

      <!-- RIGHT: Plots + KPIs -->
      <div class="card">
        <div class="plot-top">
          <div class="plot-title">Power (MW): PV / Wind / Load / Diesel / BESS / Grid-tie</div>
          <div class="legend" id="legend"></div>
        </div>
        <div class="plot-wrap">
          <canvas id="powerCanvas" width="1200" height="340"></canvas>
        </div>

        <div class="card-h">
          <div class="h">Metrics</div>
          <div class="mono" style="font-size:11px; color:var(--sub)" id="kpiHint">last update: —</div>
        </div>
        <div class="card-b">
          <div class="kpis">
            <div class="kpi"><div class="k">Fuel use</div><div class="v" id="k_fuel">—</div><div class="s">L</div></div>
            <div class="kpi"><div class="k">Renewables share</div><div class="v" id="k_ren">—</div><div class="s">%</div></div>
            <div class="kpi"><div class="k">Trips</div><div class="v" id="k_trips">—</div><div class="s">count</div></div>
            <div class="kpi"><div class="k">Min voltage</div><div class="v" id="k_vmin">—</div><div class="s">pu</div></div>
          </div>

          <div style="margin-top:10px">
            <label>Log</label>
            <textarea id="log" class="mono" style="min-height:140px" readonly></textarea>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="footer">
    <div>© <span id="year"></span> Energize-style Single-File Engineering Simulator</div>
    <div class="mono">No external libs • Copy-paste to GitHub Pages</div>
  </div>

<script>
/* =========================
   SERIES CONFIG (colors)
   ========================= */
const SERIES = [
  { key: "pv",    label: "PV",       color: "#1b9e77" },
  { key: "wind",  label: "Wind",     color: "#66a61e" },
  { key: "load",  label: "Load",     color: "#111827" },
  { key: "diesel",label: "Diesel",   color: "#f97316" },
  { key: "bess",  label: "BESS",     color: "#2563eb" },
  { key: "grid",  label: "Grid-tie", color: "#a855f7" },
];

/* =========================
   Simple plotting engine
   - no libs, deterministic
   - legend colored text
   - end-of-line labels
   - click legend to hide/show
   ========================= */
function niceNum(x){
  if (!isFinite(x)) return 0;
  const exp = Math.floor(Math.log10(Math.abs(x)+1e-9));
  const f = x / Math.pow(10, exp);
  const nf = (f < 1.5) ? 1 : (f < 3) ? 2 : (f < 7) ? 5 : 10;
  return nf * Math.pow(10, exp);
}

function buildLegend(container, state, onToggle){
  container.innerHTML = "";
  SERIES.forEach(s => {
    const it = document.createElement("span");
    it.className = "item" + (state.hidden[s.key] ? " muted" : "");
    it.dataset.key = s.key;

    const sw = document.createElement("span");
    sw.className = "sw";
    sw.style.background = s.color;

    const tx = document.createElement("span");
    tx.textContent = s.label;
    tx.style.color = s.color;              // text color matches curve

    it.appendChild(sw);
    it.appendChild(tx);
    it.addEventListener("click", () => onToggle(s.key));
    container.appendChild(it);
  });
}

function drawPowerChart(canvas, series, opts){
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  ctx.clearRect(0,0,W,H);

  const pad = {l:58, r:18, t:12, b:30};
  const plotW = W - pad.l - pad.r;
  const plotH = H - pad.t - pad.b;

  // Determine x range from series[0].t
  const t = series.t;
  const n = t.length;
  if (!n) return;

  let ymin = +Infinity, ymax = -Infinity;
  SERIES.forEach(s=>{
    if (opts.hidden[s.key]) return;
    const y = series[s.key];
    for (let i=0;i<y.length;i++){
      const v = y[i];
      if (!isFinite(v)) continue;
      ymin = Math.min(ymin, v);
      ymax = Math.max(ymax, v);
    }
  });

  if (!isFinite(ymin) || !isFinite(ymax)){
    ymin = -1; ymax = 1;
  }
  // add margin
  const span = (ymax - ymin) || 1;
  ymin -= span*0.08;
  ymax += span*0.10;

  // nice ticks
  const yStep = niceNum(span/5);
  const y0 = Math.floor(ymin / yStep) * yStep;
  const y1 = Math.ceil(ymax / yStep) * yStep;

  const xMin = t[0];
  const xMax = t[n-1];

  const xToPx = (x)=> pad.l + (x - xMin) / (xMax - xMin) * plotW;
  const yToPx = (y)=> pad.t + (y1 - y) / (y1 - y0) * plotH;

  // background
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(pad.l, pad.t, plotW, plotH);

  // grid + axes
  ctx.strokeStyle = "#e6e8ec";
  ctx.lineWidth = 1;

  ctx.beginPath();
  for (let yTick=y0; yTick<=y1+1e-9; yTick+=yStep){
    const py = yToPx(yTick);
    ctx.moveTo(pad.l, py);
    ctx.lineTo(pad.l + plotW, py);
  }
  ctx.stroke();

  // y labels
  ctx.fillStyle = "#516075";
  ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  for (let yTick=y0; yTick<=y1+1e-9; yTick+=yStep){
    const py = yToPx(yTick);
    ctx.fillText(yTick.toFixed(1), pad.l-8, py);
  }

  // x axis labels (hours)
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  const xTicks = 6;
  for (let i=0;i<=xTicks;i++){
    const x = xMin + (xMax-xMin)*i/xTicks;
    const px = xToPx(x);
    ctx.strokeStyle = "#eef0f3";
    ctx.beginPath();
    ctx.moveTo(px, pad.t);
    ctx.lineTo(px, pad.t+plotH);
    ctx.stroke();

    ctx.fillStyle = "#516075";
    const hours = x/3600;
    ctx.fillText(hours.toFixed(2) + "h", px, pad.t+plotH+8);
  }

  // axes border
  ctx.strokeStyle = "#d6dae1";
  ctx.strokeRect(pad.l, pad.t, plotW, plotH);

  // series lines
  ctx.lineWidth = 1.6;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  const endLabels = [];
  SERIES.forEach(s=>{
    if (opts.hidden[s.key]) return;
    const y = series[s.key];
    ctx.strokeStyle = s.color;
    ctx.beginPath();
    for (let i=0;i<n;i++){
      const px = xToPx(t[i]);
      const py = yToPx(y[i]);
      if (i===0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.stroke();

    // end label data
    endLabels.push({
      key: s.key,
      label: s.label,
      color: s.color,
      x: xToPx(t[n-1]),
      y: yToPx(y[n-1]),
      v: y[n-1],
    });
  });

  // end-of-line labels (colored text)
  // simple collision avoidance: sort by y and push apart
  endLabels.sort((a,b)=>a.y-b.y);
  const minGap = 12;
  for (let i=1;i<endLabels.length;i++){
    if (endLabels[i].y - endLabels[i-1].y < minGap){
      endLabels[i].y = endLabels[i-1].y + minGap;
    }
  }
  // clamp
  endLabels.forEach(e=>{
    e.y = Math.max(pad.t+2, Math.min(pad.t+plotH-2, e.y));
  });

  ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  endLabels.forEach(e=>{
    const tx = Math.min(W - pad.r - 2, e.x + 8);
    ctx.fillStyle = e.color;
    ctx.fillText(`${e.label}`, tx, e.y);
  });
}

/* =========================
   Demo data generator
   Replace getSeries() with your engine outputs
   ========================= */
function getSeries(simSeconds=24*3600, step=10){
  const t = [];
  const pv = [], wind = [], load = [], diesel = [], bess = [], grid = [];

  // quick scenario from UI state (grid/island)
  const gridOn = document.getElementById("gridConnected").value === "yes";
  const strong = document.getElementById("gridStrength").value === "strong";

  for (let s=0; s<=simSeconds; s+=step){
    t.push(s);

    // synthetic signals (placeholder)
    const day = s / 86400;
    const pvAvail = Math.max(0, Math.sin(Math.PI * Math.min(1, Math.max(0, (day*1.2))) ));
    const pvP = 8 * pvAvail;

    const windP = 2.0 + 1.2*Math.sin(2*Math.PI*day*6) + 0.8*(Math.random()-0.5);
    const baseLoad = 9.0 + 1.5*Math.sin(2*Math.PI*day*2) + 1.2*(Math.random()-0.5);
    const loadP = Math.max(6.0, baseLoad);

    // simple dispatch
    const ren = Math.max(0, pvP) + Math.max(0, windP);
    let pGrid = 0;
    let pDiesel = 0;
    let pBess = 0;

    if (gridOn){
      // grid absorbs mismatch
      const mismatch = loadP - ren;
      pGrid = mismatch * (strong ? 1.0 : 0.8);
      // diesel still carries some base if weak grid
      pDiesel = strong ? 0.8 : 2.5;
      pBess = (loadP - ren - pGrid - pDiesel);
    } else {
      // island: diesel+bess cover mismatch
      pDiesel = 3.5 + 0.6*Math.sin(2*Math.PI*day*3);
      pBess = loadP - ren - pDiesel;
      pGrid = 0;
    }

    pv.push(pvP);
    wind.push(Math.max(0, windP));
    load.push(-loadP);      // plot load as negative for visual clarity (common in microgrid plots)
    diesel.push(Math.max(0, pDiesel));
    bess.push(pBess);
    grid.push(pGrid);
  }

  return { t, pv, wind, load, diesel, bess, grid };
}

/* =========================
   App state + wiring
   ========================= */
const state = {
  hidden: Object.fromEntries(SERIES.map(s=>[s.key,false])),
  running: false,
  timer: null,
  lastSeries: null,
};

function setMeta(){
  const mode = (document.getElementById("gridConnected").value === "yes")
    ? ("GRID (" + document.getElementById("gridStrength").value.toUpperCase() + ")")
    : "ISLAND";
  document.getElementById("metaLine").textContent = `MODE: ${mode} | t=${(state.tNow||0).toFixed(2)}h`;
}

function logLine(s){
  const el = document.getElementById("log");
  el.value += s + "\n";
  el.scrollTop = el.scrollHeight;
}

function updateKPIs(){
  // placeholder KPIs; replace with real calc from engine
  document.getElementById("k_fuel").textContent = (80 + Math.random()*30).toFixed(1);
  document.getElementById("k_ren").textContent = (20 + Math.random()*15).toFixed(0);
  document.getElementById("k_trips").textContent = (Math.random()<0.2 ? 1 : 0);
  document.getElementById("k_vmin").textContent = (0.92 - Math.random()*0.25).toFixed(2);
  document.getElementById("kpiHint").textContent = "last update: " + new Date().toLocaleTimeString();
}

function render(){
  setMeta();
  if (!state.lastSeries) return;
  drawPowerChart(document.getElementById("powerCanvas"), state.lastSeries, state);
  updateKPIs();
}

function recomputeAndRender(){
  const hours = parseFloat(document.getElementById("simHours").value || "24");
  const dt = parseFloat(document.getElementById("dt").value || "0.5");
  // For browser smoothness, decimate to ~5-15s step for plotting
  const plotStep = Math.max(5, Math.min(30, Math.round(dt*10)));
  state.lastSeries = getSeries(hours*3600, plotStep);
  render();
}

function start(){
  if (state.running) return;
  state.running = true;
  document.getElementById("runState").textContent = "RUNNING";
  logLine("[start] simulation started");
  state.tNow = 0;

  // For now: demo animate time label only. You will replace this with real step loop.
  const hours = parseFloat(document.getElementById("simHours").value || "24");
  const total = hours;
  state.timer = setInterval(()=>{
    state.tNow += 0.03;
    if (state.tNow >= total) state.tNow = total;
    setMeta();
  }, 200);

  recomputeAndRender();
}

function pause(){
  if (!state.running) return;
  state.running = false;
  document.getElementById("runState").textContent = "PAUSED";
  logLine("[pause] simulation paused");
  if (state.timer){ clearInterval(state.timer); state.timer = null; }
}

function reset(){
  pause();
  state.tNow = 0;
  document.getElementById("runState").textContent = "READY";
  document.getElementById("log").value = "";
  logLine("[reset] cleared state");
  recomputeAndRender();
}

function trip(){
  document.getElementById("gridConnected").value = "no";
  logLine("[event] pcc_open (trip grid)");
  recomputeAndRender();
}

function reclose(){
  document.getElementById("gridConnected").value = "yes";
  logLine("[event] pcc_close (attempt reclose)");
  recomputeAndRender();
}

function init(){
  document.getElementById("year").textContent = new Date().getFullYear();

  const legend = document.getElementById("legend");
  buildLegend(legend, state, (key)=>{
    state.hidden[key] = !state.hidden[key];
    buildLegend(legend, state, (k)=>{ state.hidden[k] = !state.hidden[k]; buildLegend(legend, state, arguments.callee); render(); });
    render();
  });

  // Better: rebuild legend without recursion
  function toggleLegend(key){
    state.hidden[key] = !state.hidden[key];
    buildLegend(legend, state, toggleLegend);
    render();
  }
  buildLegend(legend, state, toggleLegend);

  // wires
  document.getElementById("btnStart").addEventListener("click", start);
  document.getElementById("btnPause").addEventListener("click", pause);
  document.getElementById("btnReset").addEventListener("click", reset);
  document.getElementById("btnTrip").addEventListener("click", trip);
  document.getElementById("btnReclose").addEventListener("click", reclose);

  ["simHours","dt","gridConnected","gridStrength"].forEach(id=>{
    document.getElementById(id).addEventListener("change", ()=>{
      setMeta();
      recomputeAndRender();
    });
  });

  state.tNow = 0;
  setMeta();
  recomputeAndRender();
}

init();
</script>
</body>
</html>
