<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Off-Grid Mining Microgrid · Single File · Progressive Charts + Trip State</title>
<meta name="description" content="Single-file microgrid simulation UI with progressive time-series rendering, mobile-friendly layout, and explicit trip/reclose state machine."/>
<style>
  :root{
    --bg:#ffffff;
    --panel:#ffffff;
    --muted:#f5f6f8;
    --border:#d9dde3;
    --text:#0b1220;
    --sub:#516075;

    --btn:#111111;
    --btnText:#ffffff;
    --danger:#b42318;
    --ok:#027a48;
    --warn:#b54708;

    --shadow: 0 8px 24px rgba(16,24,40,.08);

    --radius:14px;
    --gap:12px;

    --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  }

  html,body{height:100%}
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family:var(--font);
    line-height:1.35;
  }

  .wrap{
    max-width:1100px;
    margin:0 auto;
    padding:18px 14px 34px;
  }

  h1{
    margin:0 0 6px;
    font-size:18px;
    letter-spacing:.2px;
  }
  .sub{
    color:var(--sub);
    font-size:13px;
    margin:0 0 14px;
  }

  .grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:var(--gap);
    align-items:start;
  }

  .card{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:14px;
  }

  .card h2{
    margin:0 0 10px;
    font-size:16px;
  }

  .row{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }

  .kvs{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
  }

  .field{
    display:flex;
    flex-direction:column;
    gap:6px;
    min-width: 160px;
    flex: 1;
  }
  label{
    font-size:12px;
    color:var(--sub);
  }
  input, select, textarea{
    border:1px solid var(--border);
    border-radius:10px;
    padding:10px 10px;
    font-size:14px;
    outline:none;
    background:#fff;
    color:var(--text);
  }
  input:focus, select:focus, textarea:focus{
    box-shadow: 0 0 0 3px rgba(17,17,17,.12);
    border-color:#b8bdc6;
  }

  .btn{
    appearance:none;
    border:1px solid #0f172a;
    background:var(--btn);
    color:var(--btnText);
    padding:10px 12px;
    border-radius:12px;
    cursor:pointer;
    font-weight:700;
    font-size:13px;
    letter-spacing:.2px;
  }
  .btn:active{transform:translateY(1px)}
  .btn.secondary{
    background:#fff;
    color:#111;
    border:1px solid var(--border);
    font-weight:700;
  }
  .btn.danger{
    background:var(--danger);
    border-color:var(--danger);
  }
  .btn:disabled{
    opacity:.55;
    cursor:not-allowed;
  }

  .pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:8px 10px;
    border:1px solid var(--border);
    border-radius:999px;
    background:var(--muted);
    font-size:12px;
    color:var(--sub);
  }
  .dot{
    width:10px;height:10px;border-radius:999px;background:#9aa4b2;
  }
  .dot.ok{background:var(--ok)}
  .dot.warn{background:var(--warn)}
  .dot.bad{background:var(--danger)}

  .statusbar{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:space-between;
    flex-wrap:wrap;
    margin-top:8px;
  }
  .statusbar .left{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

  /* Charts */
  .chartWrap{
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .chartTitle{
    font-weight:800;
    font-size:14px;
    margin:0;
  }
  .legend{
    display:flex;
    flex-wrap:wrap;
    gap:8px 10px;
    align-items:center;
  }
  .legend.scroll{
    flex-wrap:nowrap;
    overflow:auto;
    -webkit-overflow-scrolling: touch;
    padding-bottom:2px;
  }
  .lg{
    display:inline-flex;
    align-items:center;
    gap:8px;
    border:1px solid var(--border);
    background:#fff;
    padding:6px 9px;
    border-radius:999px;
    font-size:12px;
    color:var(--sub);
    white-space:nowrap;
    flex: 0 0 auto;
  }
  .sw{
    width:12px;height:12px;border-radius:4px;
    border:1px solid rgba(0,0,0,.15);
  }

  .canvasWrap{
    position:relative;
  }

  canvas{
    width:100%;
    height:360px;
    border:1px solid var(--border);
    border-radius:14px;
    background:#fff;
    display:block;
  }

  .tooltip{
    position:absolute;
    pointer-events:none;
    opacity:0;
    transform: translate(-50%, -100%);
    background:#0b1220;
    color:#fff;
    padding:8px 10px;
    border-radius:12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.18);
    font-size:12px;
    min-width: 210px;
  }
  .tooltip .t{opacity:.92; font-weight:800; margin-bottom:4px}
  .tooltip .line{display:flex; justify-content:space-between; gap:10px; opacity:.9}
  .tooltip .k{color:#cbd5e1}
  .tooltip .v{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

  .hint{
    color:var(--sub);
    font-size:12px;
    margin:0;
  }

  .mini{
    display:flex;
    flex-direction:column;
    gap:8px;
    margin-top:10px;
    padding-top:10px;
    border-top:1px dashed var(--border);
  }
  .logbox{
    border:1px solid var(--border);
    background:#fff;
    border-radius:12px;
    padding:10px;
    max-height:180px;
    overflow:auto;
    font-size:12px;
  }
  .logline{
    display:flex;
    justify-content:space-between;
    gap:10px;
    padding:6px 0;
    border-bottom:1px solid #f1f3f6;
  }
  .logline:last-child{border-bottom:none}
  .tag{
    font-size:11px;
    border:1px solid var(--border);
    background:var(--muted);
    padding:2px 8px;
    border-radius:999px;
    color:var(--sub);
    white-space:nowrap;
  }
  .tag.bad{border-color: rgba(180,35,24,.25); color: var(--danger); background: rgba(180,35,24,.08)}
  .tag.ok{border-color: rgba(2,122,72,.25); color: var(--ok); background: rgba(2,122,72,.08)}
  .tag.warn{border-color: rgba(181,71,8,.25); color: var(--warn); background: rgba(181,71,8,.08)}

  .progress{
    width:100%;
    height:10px;
    background:#eef1f5;
    border:1px solid var(--border);
    border-radius:999px;
    overflow:hidden;
  }
  .bar{
    height:100%;
    width:0%;
    background:#111;
  }
  .bar.bad{background: var(--danger)}
  .bar.ok{background: var(--ok)}
  .bar.warn{background: var(--warn)}

  /* Mobile */
  @media (max-width: 900px){
    .grid{grid-template-columns:1fr}
    canvas{height:320px}
    .kvs{grid-template-columns:1fr}
    .legend{display:none}
    .legend.scroll{display:flex}
  }
  @media (max-width: 420px){
    .wrap{padding:14px 10px 26px}
    .btn{width:100%}
    .row{gap:8px}
    canvas{height:280px}
    input,select{font-size:16px} /* avoid iOS zoom */
  }
</style>
</head>

<body>
<div class="wrap">
  <h1>Microgrid Simulation · Single File</h1>
  <p class="sub">Power / Frequency / Vmin / SOC charts render progressively over time (like a “playhead”), with optional scroll-window mode. Trip/Reclose is a visible state machine with explicit timers + progress.</p>

  <div class="grid">
    <!-- Controls -->
    <div class="card">
      <h2>Controls</h2>

      <div class="kvs">
        <div class="field">
          <label>Mode</label>
          <select id="mode">
            <option value="grid">Grid-tied</option>
            <option value="island">Islanded</option>
          </select>
        </div>

        <div class="field">
          <label>Time step (s)</label>
          <input id="dt" type="number" value="0.5" min="0.05" step="0.05"/>
        </div>

        <div class="field">
          <label>Playback speed</label>
          <select id="speed">
            <option value="1">1×</option>
            <option value="2">2×</option>
            <option value="5" selected>5×</option>
            <option value="10">10×</option>
            <option value="20">20×</option>
          </select>
        </div>

        <div class="field">
          <label>Power chart render</label>
          <select id="powerRenderMode">
            <option value="progressive" selected>Progressive (from 0 to now)</option>
            <option value="window">Scroll window (last N minutes)</option>
          </select>
        </div>

        <div class="field">
          <label>Window size (min, for scroll window)</label>
          <input id="windowMin" type="number" value="10" min="1" step="1"/>
        </div>

        <div class="field">
          <label>Export CSV (demo)</label>
          <button class="btn secondary" id="exportBtn">Export current series</button>
        </div>

        <div class="field">
          <label>Show playhead + future mask</label>
          <select id="playhead">
            <option value="on" selected>On</option>
            <option value="off">Off</option>
          </select>
        </div>

        <div class="field">
          <label>Tooltips (tap/hover)</label>
          <select id="tooltips">
            <option value="on" selected>On</option>
            <option value="off">Off</option>
          </select>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid var(--border);margin:14px 0"/>

      <div class="kvs">
        <div class="field">
          <label>Trip delay (s) — OPEN command delay</label>
          <input id="tripDelay" type="number" value="0.25" min="0" step="0.05"/>
        </div>
        <div class="field">
          <label>Reclose after trip (s) — CLOSE scheduling</label>
          <input id="recloseDelay" type="number" value="30" min="0" step="1"/>
        </div>

        <div class="field">
          <label>Reclose policy</label>
          <select id="reclosePolicy">
            <option value="auto" selected>Auto reclose (timer)</option>
            <option value="manual">Manual reclose (button)</option>
            <option value="lockout">Lockout (no reclose)</option>
          </select>
        </div>

        <div class="field">
          <label>Manual Close button</label>
          <button class="btn secondary" id="manualCloseBtn" disabled>Close now</button>
        </div>

        <div class="field">
          <label>UVLS stages (comma % of total load)</label>
          <input id="uvlsStages" type="text" value="10,10,10"/>
        </div>
        <div class="field">
          <label>UVLS note</label>
          <input type="text" value="Triggers when Vmin stays below UV for delay; each stage sheds that % of total load." disabled/>
        </div>
      </div>

      <div class="statusbar">
        <div class="left">
          <span class="pill"><span class="dot" id="gridDot"></span> <span id="gridState">Grid: Connected</span></span>
          <span class="pill mono">t = <span id="tNow">0.0</span>s</span>
          <span class="pill mono">run = <span id="runState">stopped</span></span>
        </div>
        <div class="row">
          <button class="btn" id="startBtn">Start</button>
          <button class="btn secondary" id="pauseBtn" disabled>Pause</button>
          <button class="btn secondary" id="resetBtn">Reset</button>
          <button class="btn danger" id="tripBtn">Trip</button>
          <button class="btn secondary" id="cancelTripBtn" disabled>Cancel trip</button>
        </div>
      </div>

      <div class="card" style="margin-top:12px;border-radius:12px;box-shadow:none;background:var(--muted)">
        <div class="row" style="justify-content:space-between">
          <div>
            <div style="font-weight:800;font-size:13px">Trip/Reclose Status</div>
            <div class="hint" id="tripHint">Armed. Press Trip to request a trip sequence.</div>
          </div>
          <div class="pill mono" id="tripPill">state=ARMED</div>
        </div>

        <div style="margin-top:10px" class="hint mono" id="tripTimeline">
          ARMED → (Trip) → TRIP_COUNTDOWN → OPENED → RECLOSE_COUNTDOWN → CLOSED → ARMED
        </div>

        <div class="mini">
          <div class="row" style="justify-content:space-between">
            <div class="hint"><span class="mono">Trip delay</span> progress</div>
            <div class="hint mono" id="tripDelayLine">0.00 / 0.25 s</div>
          </div>
          <div class="progress"><div class="bar bad" id="tripDelayBar"></div></div>

          <div class="row" style="justify-content:space-between">
            <div class="hint"><span class="mono">Reclose</span> countdown</div>
            <div class="hint mono" id="recloseDelayLine">0.0 / 30 s</div>
          </div>
          <div class="progress"><div class="bar ok" id="recloseDelayBar"></div></div>
        </div>
      </div>

      <div class="mini">
        <div class="row" style="justify-content:space-between">
          <div style="font-weight:800;font-size:13px">Event log</div>
          <div class="row">
            <span class="tag" id="logTag">ready</span>
            <button class="btn secondary" id="clearLogBtn">Clear</button>
          </div>
        </div>
        <div class="logbox" id="logBox"></div>
        <p class="hint">Log records Trip/Open/Close commands and state transitions. This makes the timers “explain themselves”.</p>
      </div>
    </div>

    <!-- Charts -->
    <div class="card">
      <div class="chartWrap">
        <div>
          <p class="chartTitle">Power (MW): PV / Wind / Load / Diesel / BESS / Grid-tie</p>
          <p class="hint">
            Fix: power chart renders ONLY up to the current simulation time (playhead). It will not “paint the future” at t=0.
            Window mode shows only the last N minutes.
          </p>
        </div>

        <div class="legend" id="powerLegend"></div>
        <div class="legend scroll" id="powerLegendMobile"></div>
        <div class="canvasWrap">
          <canvas id="powerCanvas" width="1200" height="520"></canvas>
          <div class="tooltip" id="powerTip"></div>
        </div>

        <div style="height:6px"></div>

        <div>
          <p class="chartTitle">Frequency (Hz) + Vmin (pu) + SOC (%)</p>
          <p class="hint">Same progressive rendering style; tick labels dynamically skip/rotate to prevent overlap on mobile.</p>
        </div>

        <div class="legend" id="stateLegend"></div>
        <div class="legend scroll" id="stateLegendMobile"></div>
        <div class="canvasWrap">
          <canvas id="stateCanvas" width="1200" height="520"></canvas>
          <div class="tooltip" id="stateTip"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* ============================================================================
  Single-file microgrid UI (expanded)
  - No external libs
  - Progressive chart rendering with playhead (fixes "curve fills axis at start")
  - Tick label overlap mitigation (skip + rotate based on width)
  - Mobile improvements: scroll legend + adaptive paddings
  - Tooltips on hover/tap (debugging-friendly)
  - Trip/Reclose: explicit machine + progress bars + cancel + policy
============================================================================ */

/* -----------------------------
  Utilities
----------------------------- */
const $ = (id) => document.getElementById(id);

function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }

function parseCommaPercents(str){
  const arr = (str || "").split(",").map(s => Number(String(s).trim())).filter(n => Number.isFinite(n) && n>0);
  return arr.length ? arr : [10,10,10];
}

function downloadText(filename, text){
  const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function fmtTimeSec(t){
  if(!Number.isFinite(t)) return "—";
  if(t >= 3600) return (t/3600).toFixed(2) + "h";
  if(t >= 60) return (t/60).toFixed(2) + "m";
  return t.toFixed(2) + "s";
}

function nowISO(){
  const d = new Date();
  const pad = (n)=> String(n).padStart(2,"0");
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}

/* -----------------------------
  Event log (for trip clarity)
----------------------------- */
const LOG = [];
function logEvent(kind, msg){
  const entry = {ts: sim ? sim.t : 0, kind, msg, wall: nowISO()};
  LOG.push(entry);
  if(LOG.length > 250) LOG.splice(0, LOG.length - 250);
  renderLog();
}

function renderLog(){
  const box = $("logBox");
  const tag = $("logTag");
  if(!box) return;

  const st = sim.trip.state;
  tag.textContent = st.toLowerCase();
  tag.className = "tag " + (st.includes("TRIP") || st.includes("OPEN") ? "bad" : (st.includes("RECLOSE") || st.includes("CLOSED") ? "ok" : ""));

  box.innerHTML = "";
  if(!LOG.length){
    box.innerHTML = `<div class="hint">No events yet.</div>`;
    return;
  }

  // show newest on top
  const items = LOG.slice().reverse();
  for(const e of items){
    const row = document.createElement("div");
    row.className = "logline";
    const left = document.createElement("div");
    left.innerHTML = `<span class="mono">t=${e.ts.toFixed(2)}s</span> · <span class="tag ${e.kind==="TRIP"||e.kind==="OPEN"?"bad":(e.kind==="CLOSE"?"ok":"")}">${e.kind}</span> <span style="margin-left:6px">${escapeHtml(e.msg)}</span>`;
    const right = document.createElement("div");
    right.className = "hint mono";
    right.textContent = e.wall;
    row.appendChild(left);
    row.appendChild(right);
    box.appendChild(row);
  }
}

function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

/* -----------------------------
  Chart Renderer (Canvas)
  - Progressive reveal (slice series)
  - Window mode
  - Tick label overlap mitigation (skip labels)
  - Playhead + future mask
  - Tooltip coordinate mapping support
----------------------------- */
function makeChart(canvas, opts){
  const ctx = canvas.getContext("2d");
  const cfg = Object.assign({
    paddingL: 64,
    paddingR: 18,
    paddingT: 18,
    paddingB: 54,
    gridX: 6,
    gridY: 5,
    font: "12px ui-sans-serif, system-ui",
    axisColor: "#111",
    gridColor: "#e6e8ec",
    textColor: "#516075",
    bg: "#fff",
    yLabel: "",
    y2Label: "",
    showZeroLine: true,
    zeroColor: "#c7cdd6",
    playhead: true,
    playheadColor: "#111",
    futureMask: true,
    futureMaskColor: "rgba(11,18,32,.06)",
    tickRotateDeg: 0,
    // extra mobile tuning
    minTickPx: 76,      // minimum pixel spacing between x labels before skipping
    yDecimals: 2,
  }, opts || {});

  let lastAxes = null;

  function resizeToCss(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(320, Math.floor(rect.width * dpr));
    const h = Math.max(240, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
    return {w, h, dpr};
  }

  function niceTicks(min, max, count){
    if(!Number.isFinite(min) || !Number.isFinite(max) || min===max){
      return {min: min-1, max:max+1, step:1};
    }
    const span = Math.abs(max - min);
    const raw = span / Math.max(1, count);
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const steps = [1,2,5,10].map(k => k*pow);
    let step = steps[0];
    for(const s of steps){ if(raw <= s){ step = s; break; } }
    const niceMin = Math.floor(min/step)*step;
    const niceMax = Math.ceil(max/step)*step;
    return {min:niceMin, max:niceMax, step};
  }

  function adaptivePadding(w){
    // Mobile padding shrink (prevents tick overlap)
    const narrow = w < 520;
    const mid = w < 900;
    const PL = narrow ? 52 : (mid ? 58 : cfg.paddingL);
    const PR = narrow ? 14 : cfg.paddingR;
    const PB = narrow ? 58 : cfg.paddingB;
    return {PL, PR, PB};
  }

  function drawAxes(xMin, xMax, yMin, yMax, y2Min, y2Max, playheadX){
    const {w,h} = resizeToCss();
    const isNarrow = w < 900;
    const rotate = isNarrow ? -28 : 0;

    const pad = adaptivePadding(w);
    const PL = pad.PL, PR = pad.PR, PB = pad.PB, PT = cfg.paddingT;

    ctx.fillStyle = cfg.bg;
    ctx.fillRect(0,0,w,h);

    ctx.font = cfg.font;
    ctx.textBaseline = "middle";
    ctx.textAlign = "left";

    const x0 = PL, x1 = w-PR;
    const y0 = h-PB, y1 = PT;

    // Grid
    ctx.strokeStyle = cfg.gridColor;
    ctx.lineWidth = 1;

    for(let i=0;i<=cfg.gridX;i++){
      const t = i/cfg.gridX;
      const x = lerp(x0, x1, t);
      ctx.beginPath();
      ctx.moveTo(x, y0);
      ctx.lineTo(x, y1);
      ctx.stroke();
    }
    for(let j=0;j<=cfg.gridY;j++){
      const t = j/cfg.gridY;
      const y = lerp(y0, y1, t);
      ctx.beginPath();
      ctx.moveTo(x0, y);
      ctx.lineTo(x1, y);
      ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = cfg.axisColor;
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(x0, y0); ctx.lineTo(x1, y0); // x
    ctx.moveTo(x0, y0); ctx.lineTo(x0, y1); // y
    ctx.stroke();

    // mapping funcs
    function mapX(v, a, b){
      const t = (v-a) / (b-a || 1);
      return lerp(x0, x1, t);
    }
    function mapY(v, a, b){
      const t = (v-a) / (b-a || 1);
      return lerp(y0, y1, 1-t);
    }

    // y ticks
    const yt = niceTicks(yMin, yMax, cfg.gridY);
    ctx.fillStyle = cfg.textColor;
    ctx.textAlign = "right";
    for(let j=0;j<=cfg.gridY;j++){
      const v = yt.min + (yt.max-yt.min)*(j/cfg.gridY);
      const y = mapY(v, yt.min, yt.max);
      ctx.fillText(v.toFixed(cfg.yDecimals), x0-8, y);
    }

    // y2 ticks (optional)
    let y2t = null;
    if(Number.isFinite(y2Min) && Number.isFinite(y2Max)){
      y2t = niceTicks(y2Min, y2Max, cfg.gridY);
      ctx.textAlign = "left";
      for(let j=0;j<=cfg.gridY;j++){
        const v = y2t.min + (y2t.max-y2t.min)*(j/cfg.gridY);
        const y = mapY(v, y2t.min, y2t.max);
        ctx.fillText(v.toFixed(cfg.yDecimals), x1+8, y);
      }
    }

    // x ticks (skip + rotate)
    const xt = niceTicks(xMin, xMax, cfg.gridX);
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";

    const ticks = [];
    for(let i=0;i<=cfg.gridX;i++){
      const v = xt.min + (xt.max-xt.min)*(i/cfg.gridX);
      ticks.push(v);
    }

    // Decide skipping based on pixel spacing
    const pxSpan = (x1-x0);
    const approxSpacing = pxSpan / Math.max(1, ticks.length-1);
    const skip = Math.max(1, Math.ceil(cfg.minTickPx / Math.max(1, approxSpacing)));

    for(let i=0;i<ticks.length;i++){
      if(i % skip !== 0 && i !== ticks.length-1) continue;

      const v = ticks[i];
      const x = mapX(v, xt.min, xt.max);
      const label = (v>=3600 ? (v/3600).toFixed(2)+"h" : v.toFixed(0)+"s");

      ctx.save();
      ctx.translate(x, y0+20);
      ctx.rotate(rotate*Math.PI/180);
      ctx.fillStyle = cfg.textColor;
      ctx.fillText(label, 0, 0);
      ctx.restore();
    }

    // Zero line
    if(cfg.showZeroLine && yMin < 0 && yMax > 0){
      const yZ = mapY(0, yt.min, yt.max);
      ctx.strokeStyle = cfg.zeroColor;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(x0, yZ); ctx.lineTo(x1, yZ);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Labels
    ctx.fillStyle = cfg.axisColor;
    ctx.font = "700 12px ui-sans-serif, system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";

    if(cfg.yLabel){
      ctx.save();
      ctx.translate(14, (y0+y1)/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(cfg.yLabel, 0, 0);
      ctx.restore();
    }

    if(cfg.y2Label){
      ctx.save();
      ctx.translate(w-10, (y0+y1)/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(cfg.y2Label, 0, 0);
      ctx.restore();
    }

    // Future mask (area after playhead)
    if(cfg.futureMask && Number.isFinite(playheadX)){
      const xP = clamp(playheadX, x0, x1);
      ctx.fillStyle = cfg.futureMaskColor;
      ctx.fillRect(xP, y1, (x1-xP), (y0-y1));
    }

    // Playhead line
    if(cfg.playhead && Number.isFinite(playheadX)){
      const xP = clamp(playheadX, x0, x1);
      ctx.strokeStyle = cfg.playheadColor;
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 1.4;
      ctx.beginPath();
      ctx.moveTo(xP, y0);
      ctx.lineTo(xP, y1);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    lastAxes = {w,h,x0,x1,y0,y1,mapX,mapY,xt,yt,y2t};
    return lastAxes;
  }

  function drawLines(xMin, xMax, yMin, yMax, seriesList, y2, playheadX){
    const ax = drawAxes(xMin, xMax, yMin, yMax, y2?.min, y2?.max, playheadX);

    const clipPad = 2;
    ctx.save();
    ctx.beginPath();
    ctx.rect(ax.x0-clipPad, ax.y1-clipPad, (ax.x1-ax.x0)+2*clipPad, (ax.y0-ax.y1)+2*clipPad);
    ctx.clip();

    // draw each series
    for(const s of seriesList){
      const data = s.data;
      if(!data || data.length<2) continue;

      const useY2 = !!s.y2;
      const yA = useY2 ? y2.min : ax.yt.min;
      const yB = useY2 ? y2.max : ax.yt.max;

      ctx.strokeStyle = s.color;
      ctx.lineWidth = s.width || 2.0;
      ctx.globalAlpha = s.alpha ?? 1;

      ctx.beginPath();
      let started = false;
      for(let i=0;i<data.length;i++){
        const p = data[i];
        const x = ax.mapX(p.x, ax.xt.min, ax.xt.max);
        const y = ax.mapY(p.y, yA, yB);

        if(!started){
          ctx.moveTo(x,y);
          started = true;
        }else{
          ctx.lineTo(x,y);
        }
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  return {
    render(params){
      const { xMin, xMax, yMin, yMax, series, y2, playheadX } = params;
      drawLines(xMin, xMax, yMin, yMax, series, y2, playheadX);
    },
    getAxes(){
      return lastAxes;
    }
  };
}

/* -----------------------------
  Series Model
----------------------------- */
function makeSeries(){
  return {
    t: [],

    pv: [],
    wind: [],
    load: [],
    diesel: [],
    bess: [],
    grid: [],

    f: [],
    vmin: [],
    soc: [],
  };
}
function pushPoint(arr, x, y){ arr.push({x, y}); }

/* -----------------------------
  Demo simulation state
----------------------------- */
const series = makeSeries();

let sim = {
  running: false,
  paused: false,
  t: 0,
  dt: 0.5,
  speed: 5,
  mode: "grid",

  // Trip state machine
  trip: {
    state: "ARMED",
    requestedAt: null,
    tripAt: null,
    openedAt: null,
    recloseAt: null,

    tripDelay: 0.25,
    recloseDelay: 30,
    gridConnected: true,

    // internal flags
    canceled: false
  }
};

/* -----------------------------
  Trip/Reclose State Machine
  States:
    ARMED
    TRIP_COUNTDOWN          (Trip pressed, waiting to OPEN)
    OPENED                  (Breaker OPEN executed)
    RECLOSE_COUNTDOWN       (Auto timer in progress)
    WAIT_MANUAL_CLOSE       (Manual mode)
    LOCKOUT                 (No reclose)
----------------------------- */
function setTripState(st){
  if(sim.trip.state !== st){
    sim.trip.state = st;
    $("tripPill").textContent = "state=" + st;
    logEvent("STATE", `-> ${st}`);
  }
}

function updateTripUI(){
  const st = sim.trip.state;
  const dot = $("gridDot");
  const gridTxt = $("gridState");

  if(sim.trip.gridConnected){
    dot.className = "dot ok";
    gridTxt.textContent = "Grid: Connected";
  }else{
    dot.className = "dot bad";
    gridTxt.textContent = "Grid: Disconnected";
  }

  const t = sim.t;

  // button availability
  $("tripBtn").disabled = !(st === "ARMED");
  $("cancelTripBtn").disabled = !(st === "TRIP_COUNTDOWN");
  $("manualCloseBtn").disabled = !(st === "WAIT_MANUAL_CLOSE");

  // progress bars
  const tripDelay = Number($("tripDelay").value) || 0;
  const recloseDelay = Number($("recloseDelay").value) || 0;

  // Trip delay bar
  let tripCur = 0;
  if(st === "TRIP_COUNTDOWN" && sim.trip.requestedAt != null){
    tripCur = clamp(t - sim.trip.requestedAt, 0, tripDelay);
  }else{
    tripCur = (st === "ARMED") ? 0 : tripDelay;
  }
  $("tripDelayLine").textContent = tripCur.toFixed(2) + " / " + tripDelay.toFixed(2) + " s";
  $("tripDelayBar").style.width = (tripDelay>0 ? (100*tripCur/tripDelay) : (st==="TRIP_COUNTDOWN"?100:0)) + "%";

  // Reclose bar
  let rCur = 0;
  if(st === "RECLOSE_COUNTDOWN" && sim.trip.openedAt != null){
    rCur = clamp(t - sim.trip.openedAt, 0, recloseDelay);
  }else{
    rCur = (st === "ARMED") ? 0 : (st==="OPENED" ? 0 : recloseDelay);
  }
  $("recloseDelayLine").textContent = rCur.toFixed(1) + " / " + recloseDelay.toFixed(0) + " s";
  $("recloseDelayBar").style.width = (recloseDelay>0 ? (100*rCur/recloseDelay) : 0) + "%";

  // Clear + explicit messages (your feedback: countdown felt unclear)
  if(st === "ARMED"){
    $("tripHint").textContent = "Armed. Press Trip to schedule OPEN after Trip delay. (Cancel available during countdown.)";
  }
  else if(st === "TRIP_COUNTDOWN"){
    const left = Math.max(0, sim.trip.tripAt - t);
    $("tripHint").textContent = "Trip requested. OPEN will execute in: " + left.toFixed(2) + "s (Trip delay).";
  }
  else if(st === "OPENED"){
    const pol = $("reclosePolicy").value;
    if(pol === "auto"){
      $("tripHint").textContent = "OPENED. Auto reclose will be scheduled next tick (timer starts immediately).";
    }else if(pol === "manual"){
      $("tripHint").textContent = "OPENED. Manual reclose selected. Use “Close now” when ready.";
    }else{
      $("tripHint").textContent = "OPENED. Lockout selected. No reclose will occur unless you Reset.";
    }
  }
  else if(st === "RECLOSE_COUNTDOWN"){
    const left = Math.max(0, sim.trip.recloseAt - t);
    $("tripHint").textContent = "Auto reclose scheduled. CLOSE will execute in: " + left.toFixed(1) + "s.";
  }
  else if(st === "WAIT_MANUAL_CLOSE"){
    $("tripHint").textContent = "Waiting for manual CLOSE. Press “Close now” to reconnect.";
  }
  else if(st === "LOCKOUT"){
    $("tripHint").textContent = "Lockout. Breaker stays OPEN. Reset to return to ARMED.";
  }
}

/* Called when user presses Trip */
function requestTrip(){
  if(sim.trip.state !== "ARMED") return;

  const delay = Math.max(0, Number($("tripDelay").value) || 0);
  sim.trip.tripDelay = delay;

  sim.trip.canceled = false;
  sim.trip.requestedAt = sim.t;
  sim.trip.tripAt = sim.t + delay;

  logEvent("TRIP", `Trip requested; OPEN scheduled at t=${sim.trip.tripAt.toFixed(2)}s`);
  setTripState("TRIP_COUNTDOWN");
}

/* Called when user presses Cancel trip */
function cancelTrip(){
  if(sim.trip.state !== "TRIP_COUNTDOWN") return;

  sim.trip.canceled = true;
  sim.trip.requestedAt = null;
  sim.trip.tripAt = null;

  logEvent("TRIP", "Trip canceled before OPEN");
  setTripState("ARMED");
}

/* Manual close */
function manualClose(){
  if(sim.trip.state !== "WAIT_MANUAL_CLOSE") return;
  sim.trip.gridConnected = true;
  logEvent("CLOSE", "Manual CLOSE executed; grid reconnected");
  setTripState("ARMED");
}

/* -----------------------------
  Rendering setup
----------------------------- */
const powerChart = makeChart($("powerCanvas"), {
  yLabel: "MW",
  font: "12px ui-sans-serif, system-ui",
  yDecimals: 2
});

const stateChart = makeChart($("stateCanvas"), {
  yLabel: "Hz / pu",
  y2Label: "SOC (%)",
  font: "12px ui-sans-serif, system-ui",
  yDecimals: 2
});

const COLORS = {
  pv:    "#f59e0b",
  wind:  "#b45309",
  load:  "#374151",
  diesel:"#2563eb",
  bess:  "#10b981",
  grid:  "#111827",

  f:     "#111827",
  vmin:  "#b42318",
  soc:   "#027a48"
};

function buildLegend(el, items){
  el.innerHTML = "";
  for(const it of items){
    const d = document.createElement("div");
    d.className = "lg";
    const sw = document.createElement("span");
    sw.className = "sw";
    sw.style.background = it.color;
    const name = document.createElement("span");
    name.textContent = it.label;
    d.appendChild(sw);
    d.appendChild(name);
    el.appendChild(d);
  }
}

const POWER_LEGEND = [
  {label:"PV (MW)", color:COLORS.pv},
  {label:"Wind (MW)", color:COLORS.wind},
  {label:"Load (MW)", color:COLORS.load},
  {label:"Diesel (MW)", color:COLORS.diesel},
  {label:"BESS (MW)", color:COLORS.bess},
  {label:"Grid-tie (MW)", color:COLORS.grid},
];

const STATE_LEGEND = [
  {label:"Frequency (Hz)", color:COLORS.f},
  {label:"Vmin (pu)", color:COLORS.vmin},
  {label:"SOC (%)", color:COLORS.soc},
];

buildLegend($("powerLegend"), POWER_LEGEND);
buildLegend($("powerLegendMobile"), POWER_LEGEND);
buildLegend($("stateLegend"), STATE_LEGEND);
buildLegend($("stateLegendMobile"), STATE_LEGEND);

/* -----------------------------
  Progressive render logic (core)
  - We slice arrays up to current time => no “future curve fill”
  - Window mode => show last N minutes
----------------------------- */
function lastIndexAtTime(arr, t){
  let lo=0, hi=arr.length-1, ans=-1;
  while(lo<=hi){
    const mid = (lo+hi)>>1;
    if(arr[mid].x <= t){ ans=mid; lo=mid+1; } else hi=mid-1;
  }
  return ans;
}

function firstIndexAtOrAfter(arr, t){
  // lower bound
  let lo=0, hi=arr.length-1, ans=arr.length;
  while(lo<=hi){
    const mid = (lo+hi)>>1;
    if(arr[mid].x >= t){ ans=mid; hi=mid-1; } else lo=mid+1;
  }
  return ans;
}

function sliceForRender(arr, idxFrom, idxTo){
  if(idxTo < 1) return [];
  const a = Math.max(0, idxFrom);
  const b = Math.min(arr.length, idxTo+1);
  if(b <= a) return [];
  return arr.slice(a,b);
}

function minMaxY(list){
  let mn = Infinity, mx = -Infinity;
  for(const p of list){
    if(!p) continue;
    const y = p.y;
    if(!Number.isFinite(y)) continue;
    if(y < mn) mn = y;
    if(y > mx) mx = y;
  }
  if(mn === Infinity) return {min:0, max:1};
  return {min:mn, max:mx};
}

function renderAll(){
  $("tNow").textContent = sim.t.toFixed(1);
  $("runState").textContent = sim.running ? (sim.paused ? "paused" : "running") : "stopped";

  const renderMode = $("powerRenderMode").value;
  const windowMin = Math.max(1, Number($("windowMin").value) || 10);
  const windowSec = windowMin * 60;

  // Determine render time range
  let xMin = 0;
  let xMax = Math.max(10, sim.t);

  if(renderMode === "window"){
    xMin = Math.max(0, sim.t - windowSec);
    xMax = Math.max(xMin + 1, sim.t);
  }

  // idxTo = last <= sim.t (progressive)
  const idxPv = lastIndexAtTime(series.pv, sim.t);
  const idxWind = lastIndexAtTime(series.wind, sim.t);
  const idxLoad = lastIndexAtTime(series.load, sim.t);
  const idxDiesel = lastIndexAtTime(series.diesel, sim.t);
  const idxBess = lastIndexAtTime(series.bess, sim.t);
  const idxGrid = lastIndexAtTime(series.grid, sim.t);

  // idxFrom = first >= xMin (window mode), else 0
  const idxFromPv = renderMode==="window" ? firstIndexAtOrAfter(series.pv, xMin) : 0;
  const idxFromWind = renderMode==="window" ? firstIndexAtOrAfter(series.wind, xMin) : 0;
  const idxFromLoad = renderMode==="window" ? firstIndexAtOrAfter(series.load, xMin) : 0;
  const idxFromDiesel = renderMode==="window" ? firstIndexAtOrAfter(series.diesel, xMin) : 0;
  const idxFromBess = renderMode==="window" ? firstIndexAtOrAfter(series.bess, xMin) : 0;
  const idxFromGrid = renderMode==="window" ? firstIndexAtOrAfter(series.grid, xMin) : 0;

  const pPv = sliceForRender(series.pv, idxFromPv, idxPv);
  const pWind = sliceForRender(series.wind, idxFromWind, idxWind);
  const pLoad = sliceForRender(series.load, idxFromLoad, idxLoad);
  const pDiesel = sliceForRender(series.diesel, idxFromDiesel, idxDiesel);
  const pBess = sliceForRender(series.bess, idxFromBess, idxBess);
  const pGrid = sliceForRender(series.grid, idxFromGrid, idxGrid);

  // y range auto based ONLY on visible points
  const allP = [pPv,pWind,pLoad,pDiesel,pBess,pGrid].flat();
  let yMin = 0, yMax = 1;
  if(allP.length){
    const mm = minMaxY(allP);
    yMin = mm.min; yMax = mm.max;
    const pad = (yMax-yMin || 1) * 0.12;
    yMin -= pad; yMax += pad;
  }

  // playhead + mask toggle
  const play = $("playhead").value === "on";
  const playheadX = play ? sim.t : null;

  powerChart.render({
    xMin, xMax,
    yMin, yMax,
    playheadX,
    series: [
      {data:pPv, color:COLORS.pv, width:2.2},
      {data:pWind, color:COLORS.wind, width:2.0, alpha:.95},
      {data:pLoad, color:COLORS.load, width:2.2},
      {data:pDiesel, color:COLORS.diesel, width:2.1},
      {data:pBess, color:COLORS.bess, width:2.1},
      {data:pGrid, color:COLORS.grid, width:2.0, alpha:.9},
    ]
  });

  // State chart
  const idxF = lastIndexAtTime(series.f, sim.t);
  const idxV = lastIndexAtTime(series.vmin, sim.t);
  const idxS = lastIndexAtTime(series.soc, sim.t);

  const idxFromF = renderMode==="window" ? firstIndexAtOrAfter(series.f, xMin) : 0;
  const idxFromV = renderMode==="window" ? firstIndexAtOrAfter(series.vmin, xMin) : 0;
  const idxFromS = renderMode==="window" ? firstIndexAtOrAfter(series.soc, xMin) : 0;

  const pF = sliceForRender(series.f, idxFromF, idxF);
  const pV = sliceForRender(series.vmin, idxFromV, idxV);
  const pS = sliceForRender(series.soc, idxFromS, idxS);

  // y1 range covers Hz + pu on same axis (demo)
  const allY1 = [pF,pV].flat();
  let y1Min = 0.8, y1Max = 1.2;
  if(allY1.length){
    const mm = minMaxY(allY1);
    y1Min = mm.min; y1Max = mm.max;
    const pad = (y1Max-y1Min || 1)*0.18;
    y1Min -= pad; y1Max += pad;
  }

  // y2 for SOC
  let y2Min = 0, y2Max = 100;
  if(pS.length){
    const mm = minMaxY(pS);
    y2Min = mm.min; y2Max = mm.max;
    const pad = (y2Max-y2Min || 1)*0.10;
    y2Min = clamp(y2Min - pad, 0, 100);
    y2Max = clamp(y2Max + pad, 0, 100);
  }

  stateChart.render({
    xMin, xMax,
    yMin: y1Min, yMax: y1Max,
    playheadX,
    y2: {min:y2Min, max:y2Max},
    series: [
      {data:pF, color:COLORS.f, width:2.2, y2:false},
      {data:pV, color:COLORS.vmin, width:2.2, y2:false, alpha:.95},
      {data:pS, color:COLORS.soc, width:2.0, y2:true, alpha:.95},
    ]
  });

  updateTripUI();
}

/* -----------------------------
  Demo engine tick
----------------------------- */
function demoSignals(t){
  // Basic noisy profiles (MW)
  const load = 2.2 + 0.35*Math.sin(t/18) + 0.15*Math.sin(t/4) + 0.12*(Math.random()-0.5);
  const pv   = 0.8 + 0.6*Math.max(0, Math.sin((t/80)+0.6)) + 0.10*(Math.random()-0.5);
  const wind = 1.1 + 0.8*Math.sin(t/10) + 0.25*(Math.random()-0.5);

  let grid = sim.trip.gridConnected ? 0.6 + 0.4*Math.sin(t/25) : 0.0;

  // Diesel + BESS try to balance (very simplified)
  let net = load - (pv + wind + grid);
  let diesel = clamp(net*0.55, 0, 3.2);
  let bess = net - diesel;

  // clamp BESS power
  bess = clamp(bess, -2.0, 2.0);

  // Frequency and Vmin (toy model)
  const islandPenalty = sim.trip.gridConnected ? 0 : 1;
  const freq = 60 + (islandPenalty? (-0.25 + 0.15*Math.sin(t/6)) : (0.05*Math.sin(t/9))) + 0.02*(Math.random()-0.5);

  let vmin = 1.0 - (islandPenalty? 0.06 : 0.01) - 0.02*Math.max(0, net) + 0.01*Math.sin(t/7) + 0.01*(Math.random()-0.5);
  vmin = clamp(vmin, 0.75, 1.05);

  // SOC (toy integration)
  const prevSoc = series.soc.length ? series.soc[series.soc.length-1].y : 55;
  const soc = clamp(prevSoc - (bess*0.02) + 0.002*(Math.random()-0.5), 0, 100);

  return {pv, wind, load, diesel, bess, grid, freq, vmin, soc};
}

/* -----------------------------
  UVLS (demo structure)
----------------------------- */
let uvls = { stage:0, lastTriggerT:null };

function applyUvls(loadMw, vmin, t){
  const stages = parseCommaPercents($("uvlsStages").value);
  const UV = 0.88;         // demo threshold
  const UV_DELAY = 0.25;   // demo delay seconds

  if(vmin < UV){
    if(uvls.lastTriggerT === null) uvls.lastTriggerT = t;
    const belowFor = t - uvls.lastTriggerT;
    if(belowFor >= UV_DELAY && uvls.stage < stages.length){
      const shedPct = stages[uvls.stage] / 100;
      uvls.stage++;
      uvls.lastTriggerT = t;
      logEvent("UVLS", `Stage ${uvls.stage} shed ${(shedPct*100).toFixed(0)}% of load (Vmin=${vmin.toFixed(3)}pu)`);
      return loadMw * (1 - shedPct);
    }
  }else{
    uvls.lastTriggerT = null;
    uvls.stage = 0;
  }
  return loadMw;
}

/* -----------------------------
  Trip state progression in tick()
  - Clarified: only TRIP_COUNTDOWN uses tripAt
  - OPENED decides policy immediately (auto/manual/lockout)
----------------------------- */
function tickTripState(){
  const st = sim.trip.state;
  const t = sim.t;

  if(st === "TRIP_COUNTDOWN"){
    if(sim.trip.canceled){
      setTripState("ARMED");
      return;
    }
    if(t >= sim.trip.tripAt){
      // OPEN breaker now
      sim.trip.gridConnected = false;
      sim.trip.openedAt = t;
      logEvent("OPEN", "Breaker OPEN executed (grid disconnected)");
      setTripState("OPENED");

      const policy = $("reclosePolicy").value;
      const recloseDelay = Math.max(0, Number($("recloseDelay").value) || 0);
      sim.trip.recloseDelay = recloseDelay;

      if(policy === "auto"){
        sim.trip.recloseAt = t + recloseDelay;
        if(recloseDelay > 0){
          logEvent("CLOSE", `Auto CLOSE scheduled at t=${sim.trip.recloseAt.toFixed(2)}s`);
          setTripState("RECLOSE_COUNTDOWN");
        }else{
          sim.trip.gridConnected = true;
          logEvent("CLOSE", "Auto CLOSE immediate (0s delay)");
          setTripState("ARMED");
        }
      }
      else if(policy === "manual"){
        logEvent("CLOSE", "Manual reclose selected; waiting for operator");
        setTripState("WAIT_MANUAL_CLOSE");
      }
      else{
        logEvent("CLOSE", "Lockout selected; no reclose will happen");
        setTripState("LOCKOUT");
      }
    }
  }
  else if(st === "RECLOSE_COUNTDOWN"){
    if(t >= sim.trip.recloseAt){
      sim.trip.gridConnected = true;
      logEvent("CLOSE", "Auto CLOSE executed; grid reconnected");
      setTripState("ARMED");
    }
  }
  else{
    // OPENED / WAIT_MANUAL_CLOSE / LOCKOUT / ARMED do nothing in tick
  }
}

/* -----------------------------
  Main loop
----------------------------- */
let raf = null;
let lastWall = null;

function loop(wallTs){
  if(!sim.running) return;

  if(sim.paused){
    lastWall = wallTs;
    raf = requestAnimationFrame(loop);
    return;
  }

  if(lastWall === null) lastWall = wallTs;
  const wallDt = Math.min(0.05, Math.max(0, (wallTs - lastWall) / 1000));
  lastWall = wallTs;

  const speed = Number($("speed").value) || 1;
  sim.speed = speed;

  // advance simulation time
  sim.dt = Number($("dt").value) || 0.5;

  // stable series density: fixed-step integration
  let steps = Math.floor((wallDt * speed) / sim.dt);
  steps = clamp(steps, 1, 20);

  for(let k=0;k<steps;k++){
    sim.t += sim.dt;

    // trip state progression
    tickTripState();

    // generate signals
    const s = demoSignals(sim.t);

    // UVLS demo: modify load based on Vmin
    const load2 = applyUvls(s.load, s.vmin, sim.t);

    pushPoint(series.pv, sim.t, s.pv);
    pushPoint(series.wind, sim.t, s.wind);
    pushPoint(series.load, sim.t, load2);
    pushPoint(series.diesel, sim.t, s.diesel);
    pushPoint(series.bess, sim.t, s.bess);
    pushPoint(series.grid, sim.t, s.grid);

    pushPoint(series.f, sim.t, s.freq);
    pushPoint(series.vmin, sim.t, s.vmin);
    pushPoint(series.soc, sim.t, s.soc);

    // keep arrays bounded (avoid infinite memory)
    const MAX_POINTS = 20000;
    for(const key of Object.keys(series)){
      if(Array.isArray(series[key]) && series[key].length > MAX_POINTS){
        series[key].splice(0, series[key].length - MAX_POINTS);
      }
    }
  }

  renderAll();
  raf = requestAnimationFrame(loop);
}

/* -----------------------------
  Tooltips (hover/tap)
  - shows nearest point values at hovered time
----------------------------- */
function nearestPoint(arr, t){
  if(!arr || !arr.length) return null;
  const idx = lastIndexAtTime(arr, t);
  if(idx < 0) return null;
  const a = arr[idx];
  const b = arr[idx+1];
  if(!b) return a;
  return (Math.abs(a.x - t) <= Math.abs(b.x - t)) ? a : b;
}

function bindTooltip(canvas, chart, tipEl, getters){
  let active = false;

  function showAt(clientX, clientY){
    if($("tooltips").value !== "on") return;
    const ax = chart.getAxes();
    if(!ax) return;

    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    const xCss = clientX - rect.left;
    const yCss = clientY - rect.top;

    // clamp to plot area
    const x = xCss * dpr;
    const y = yCss * dpr;

    if(x < ax.x0 || x > ax.x1 || y < ax.y1 || y > ax.y0){
      tipEl.style.opacity = 0;
      return;
    }

    // invert x to time
    const tMin = ax.xt.min, tMax = ax.xt.max;
    const t = tMin + ((x - ax.x0) / ((ax.x1-ax.x0)||1)) * (tMax - tMin);

    const data = getters(t);
    if(!data) return;

    tipEl.style.opacity = 1;
    tipEl.style.left = xCss + "px";
    tipEl.style.top = yCss + "px";
    tipEl.innerHTML = data;
  }

  function onMove(e){
    active = true;
    if(e.touches && e.touches[0]){
      showAt(e.touches[0].clientX, e.touches[0].clientY);
    }else{
      showAt(e.clientX, e.clientY);
    }
  }
  function onLeave(){
    active = false;
    tipEl.style.opacity = 0;
  }

  canvas.addEventListener("mousemove", onMove);
  canvas.addEventListener("mouseleave", onLeave);
  canvas.addEventListener("touchstart", onMove, {passive:true});
  canvas.addEventListener("touchmove", onMove, {passive:true});
  canvas.addEventListener("touchend", onLeave);
}

bindTooltip($("powerCanvas"), powerChart, $("powerTip"), (t) => {
  const pv = nearestPoint(series.pv, t);
  const wind = nearestPoint(series.wind, t);
  const load = nearestPoint(series.load, t);
  const diesel = nearestPoint(series.diesel, t);
  const bess = nearestPoint(series.bess, t);
  const grid = nearestPoint(series.grid, t);

  if(!pv) return null;
  const tt = pv.x;
  return `
    <div class="t">t = ${fmtTimeSec(tt)}</div>
    <div class="line"><span class="k">PV</span><span class="v">${(pv?.y??0).toFixed(3)} MW</span></div>
    <div class="line"><span class="k">Wind</span><span class="v">${(wind?.y??0).toFixed(3)} MW</span></div>
    <div class="line"><span class="k">Load</span><span class="v">${(load?.y??0).toFixed(3)} MW</span></div>
    <div class="line"><span class="k">Diesel</span><span class="v">${(diesel?.y??0).toFixed(3)} MW</span></div>
    <div class="line"><span class="k">BESS</span><span class="v">${(bess?.y??0).toFixed(3)} MW</span></div>
    <div class="line"><span class="k">Grid-tie</span><span class="v">${(grid?.y??0).toFixed(3)} MW</span></div>
  `;
});

bindTooltip($("stateCanvas"), stateChart, $("stateTip"), (t) => {
  const f = nearestPoint(series.f, t);
  const v = nearestPoint(series.vmin, t);
  const s = nearestPoint(series.soc, t);
  if(!f) return null;
  const tt = f.x;
  return `
    <div class="t">t = ${fmtTimeSec(tt)}</div>
    <div class="line"><span class="k">Frequency</span><span class="v">${(f?.y??0).toFixed(3)} Hz</span></div>
    <div class="line"><span class="k">Vmin</span><span class="v">${(v?.y??0).toFixed(3)} pu</span></div>
    <div class="line"><span class="k">SOC</span><span class="v">${(s?.y??0).toFixed(1)} %</span></div>
  `;
});

/* -----------------------------
  Controls wiring
----------------------------- */
$("mode").addEventListener("change", () => {
  sim.mode = $("mode").value;
  logEvent("MODE", "Mode set to " + sim.mode);
});

$("reclosePolicy").addEventListener("change", () => {
  const p = $("reclosePolicy").value;
  logEvent("CFG", "Reclose policy = " + p);
  updateTripUI();
});

$("manualCloseBtn").addEventListener("click", () => {
  manualClose();
  renderAll();
});

$("startBtn").addEventListener("click", () => {
  if(!sim.running){
    sim.running = true;
    sim.paused = false;
    $("pauseBtn").disabled = false;
    lastWall = null;
    logEvent("RUN", "Start");
    raf = requestAnimationFrame(loop);
  }else{
    sim.paused = false;
    logEvent("RUN", "Resume");
  }
  renderAll();
});

$("pauseBtn").addEventListener("click", () => {
  sim.paused = !sim.paused;
  $("pauseBtn").textContent = sim.paused ? "Resume" : "Pause";
  logEvent("RUN", sim.paused ? "Pause" : "Resume");
  renderAll();
});

$("resetBtn").addEventListener("click", () => {
  sim.running = false;
  sim.paused = false;
  if(raf) cancelAnimationFrame(raf);
  raf = null;
  lastWall = null;

  // clear data
  for(const k of Object.keys(series)){
    if(Array.isArray(series[k])) series[k].length = 0;
  }

  sim.t = 0;

  // reset trip state
  sim.trip.gridConnected = true;
  sim.trip.requestedAt = null;
  sim.trip.tripAt = null;
  sim.trip.openedAt = null;
  sim.trip.recloseAt = null;
  sim.trip.canceled = false;
  setTripState("ARMED");

  $("pauseBtn").textContent = "Pause";
  $("pauseBtn").disabled = true;

  logEvent("RUN", "Reset");
  renderAll();
});

$("tripBtn").addEventListener("click", () => {
  requestTrip();
  renderAll();
});

$("cancelTripBtn").addEventListener("click", () => {
  cancelTrip();
  renderAll();
});

$("clearLogBtn").addEventListener("click", () => {
  LOG.length = 0;
  renderLog();
});

$("exportBtn").addEventListener("click", () => {
  // Demo CSV export
  const header = ["t","pv","wind","load","diesel","bess","grid","freq","vmin","soc"].join(",");
  const n = Math.min(
    series.pv.length, series.wind.length, series.load.length, series.diesel.length,
    series.bess.length, series.grid.length, series.f.length, series.vmin.length, series.soc.length
  );
  const rows = [];
  for(let i=0;i<n;i++){
    rows.push([
      series.pv[i].x.toFixed(2),
      series.pv[i].y.toFixed(4),
      series.wind[i].y.toFixed(4),
      series.load[i].y.toFixed(4),
      series.diesel[i].y.toFixed(4),
      series.bess[i].y.toFixed(4),
      series.grid[i].y.toFixed(4),
      series.f[i].y.toFixed(4),
      series.vmin[i].y.toFixed(4),
      series.soc[i].y.toFixed(2),
    ].join(","));
  }
  logEvent("EXPORT", `CSV exported (${n} rows)`);
  downloadText("microgrid_series.csv", header + "\n" + rows.join("\n"));
});

window.addEventListener("resize", () => renderAll());

/* -----------------------------
  Initial render + initial log
----------------------------- */
logEvent("BOOT", "UI loaded");
renderAll();
renderLog();
</script>
</body>
</html>
